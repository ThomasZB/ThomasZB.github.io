{"meta":{"title":"Thomas's Blog","subtitle":"","description":"hhh","author":"hang chen","url":"https://thomaszb.cn","root":"/"},"pages":[{"title":"所有标签","date":"2023-11-02T15:03:00.614Z","updated":"2023-02-27T07:38:53.407Z","comments":true,"path":"tags/index.html","permalink":"https://thomaszb.cn/tags/index.html","excerpt":"","text":"这是空的"},{"title":"分类","date":"2021-03-03T14:39:24.000Z","updated":"2023-02-27T07:38:53.404Z","comments":true,"path":"categories/index.html","permalink":"https://thomaszb.cn/categories/index.html","excerpt":"","text":"不知道怎么写"},{"title":"","date":"2023-11-02T15:03:00.690Z","updated":"2023-02-27T07:38:53.404Z","comments":true,"path":"about/index.html","permalink":"https://thomaszb.cn/about/index.html","excerpt":"","text":"什么都没有哦"}],"posts":[{"title":"Eigen库使用","slug":"Eigen库使用","date":"2023-11-05T03:34:22.000Z","updated":"2023-11-05T06:48:27.521Z","comments":true,"path":"2023/11/05/Eigen库使用/","link":"","permalink":"https://thomaszb.cn/2023/11/05/Eigen%E5%BA%93%E4%BD%BF%E7%94%A8/","excerpt":"Eigen库主要用于矩阵运算，由于Eigen库全都是由.h文件构成，所以兼容性特别强，Eigen库在矩阵运算上，速度也是非常的快。除此之外，Eigen库还包几何模块，可以方便的用于机器人开发。","text":"Eigen库主要用于矩阵运算，由于Eigen库全都是由.h文件构成，所以兼容性特别强，Eigen库在矩阵运算上，速度也是非常的快。除此之外，Eigen库还包几何模块，可以方便的用于机器人开发。 感觉这种代码上的文章写成博客是否有点多余了，需要什么函数直接去查文档不久行了吗。这里主要是一个记录，并不涉及Eigen内部的实现，以后有一些小技巧也会更新在上面。与其说这是博客，不如说是写给自己参考的笔记 安装和使用 安装 这一点往往是使用一个库最麻烦的步骤，不过Eigen库相较于其他库比较友好，在Ubuntu中，可以直接通过如下命令安装 1sudo apt-get install libeigen3-dev Eigen的头文件默认被安装在/usr/include/eigen3/ 此外，可以通过sudo updatedb，locate eigen3两个命令来定位Eigen 使用 根据上面的说法，不难知道，想要使用Eigen3只用包含头文件，编译的时候带上对应头文件参数即可。 头文件 头文件 用途 Eigen/Core Eige的核心部分 Eigen/Dense 稠密矩阵的代数运算（通用的） Eigen/Geometry 几何模块 为了更方便的理解使用，我举一个例子 1234567891011#include &lt;Eigen/Core&gt;#include &lt;iostream&gt;int main() &#123; Eigen::Matrix&lt;float, 2, 3&gt; matrix_23; matrix_23 &lt;&lt; 1, 2, 3, 4, 5, 6; std::cout &lt;&lt; matrix_23 &lt;&lt; std::endl; return 0;&#125; g++直接编译 如果只是测试的小文件，可以直接通过-I添加头文件目录，即可编译通过 1g++ test1.cc -I /usr/include/eigen3 使用CMake 对于较大项目，最好还是使用CMake，要在项目中使用Eigen也很简单，可以直接指定目录，不过考虑兼容性，最好还是通过find_package来寻找Eigen目录，再添加到头文件列表 对于上述的例子，可以用如下CMakeLists.txt编译通过 123456789cmake_minimum_required(VERSION 3.0)project(eigen_test)# Find Eigen libraryfind_package(Eigen3 REQUIRED)include_directories($&#123;EIGEN3_INCLUDE_DIR&#125;)# Add executableadd_executable(eigen_test test1.cc) 基本操作 这一章节，我主要记录Eigen库作为矩阵运算库的常见操作，比如定义、基本运算、常用算法等。 矩阵定义 Eigen中，所有的向量和矩阵都是Eigen::Matrix。它是一个模板类，前三个参数分别为类型，行，列，下面直接通过代码来说明 1234567891011121314// 定义一个两行三列的float矩阵Eigen::Matrix&lt;float, 2, 3&gt; matrix_23;// 定义一个三维向量，类型为double，两种方式等价Eigen::Vector3d v_3d;Eigen::Matrix&lt;double, 3, 1&gt; vd_3d;// 定义一个3x3的矩阵，初始化为0Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::Zero();// 如果不确定矩阵大小，或者矩阵较大，可以使用动态大小的矩阵Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt; matrix_dynamic(200,200);// 和上面等价Eigen::MatrixXd matrix_x;matrix_x.resize(200,200); 有时候我们还需要创建一些特殊矩阵，比如单位阵，0矩阵、随机矩阵等等 123456789101112131415161718192021222324252627Eigen::Matrix&lt;float, 2, 3&gt; matrix_23;matrix_23 &lt;&lt; 1, 2, 3, 4, 5, 6; // 初始化一个矩阵// 定义单位矩阵Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::Identity();Eigen::MatrixXd matrix_x = Eigen::MatrixXd::Identity(200, 200);matrix_x.setIdentity();// 定义0矩阵Eigen::MatrixXd matrix_y;matrix_y = Eigen::MatrixXd::Zero(3, 3);matrix_y.setZero();matrix_y.setZero(3, 3); // 也可以跟参数// 定义随机矩阵，生成的随机数范围在[-1,1]内Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt; matrix_dynamic;matrix_dynamic = Eigen::MatrixXd::Random(3, 3);matrix_dynamic.setRandom();// 定义全1矩阵matrix_dynamic = Eigen::MatrixXd::Ones(3, 3);matrix_dynamic.setOnes();// 定义混合矩阵Eigen::MatrixXd matrix_h(200, 200);matrix_h &lt;&lt; Eigen::MatrixXd::Random(100, 200), Eigen::MatrixXd::Zero(100, 200); 矩阵读取和分块 读取某个元素：这里介绍一下矩阵的读取，可以直接通过(i,j)进行索引： 1std::cout &lt;&lt; matrix_h(0, 0) &lt;&lt; std::endl; 操作某一行或某一列：操作某一行或者某一列时也很容易 1234567// 读取第2行数据std::cout &lt;&lt; matrix_10_10.row(1) &lt;&lt; std::endl;// 读取第二列数据std::cout &lt;&lt; matrix_10_10.col(1) &lt;&lt; std::endl;// 将第二列数据置0matrix_10_10.col(1) = Eigen::VectorXd::Zero(10);std::cout &lt;&lt; matrix_10_10 &lt;&lt; std::endl; 矩阵基本分块操作：用于获取矩阵某块子矩阵，可以用于赋值和操作，使用函数block，有以下两种方法使用： 动态size 固定size 功能 matrix.block(i,j,p,q) matrix.block&lt;p,q&gt;(i,j) 从\\((i,j)\\)开始（左上角为\\(0,0\\)），大小为\\((p,q)\\)的矩阵块 这里举个例子 1234567// 输出左上角的2x2大小的矩阵std::cout &lt;&lt; matrix_10_10.block(0, 0, 2, 2) &lt;&lt; std::endl;// 这样也同理，一般提前知道大小时可以用std::cout &lt;&lt; matrix_10_10.block&lt;2, 2&gt;(0, 0) &lt;&lt; std::endl;// 也可以进行赋值matrix_10_10.block&lt;2, 2&gt;(0, 0) = Eigen::Matrix2d::Zero();std::cout &lt;&lt; matrix_10_10 &lt;&lt; std::endl; 角落块操作：有时候我们取矩阵只取矩阵某个角落的块，这时候可以用下面的这些函数进行操作 动态size 固定size 功能 matrix.topLeftCorner(p,q); matrix.topLeftCorner&lt;p,q&gt;(); 取左上角\\((p,q)\\)大小的矩阵 matrix.bottomLeftCorner(p,q); matrix.bottomLeftCorner&lt;p,q&gt;(); 取左下角\\((p,q)\\)大小的矩阵 matrix.topRightCorner(p,q); matrix.topRightCorner&lt;p,q&gt;(); 取右上角\\((p,q)\\)大小的矩阵 matrix.bottomRightCorner(p,q); matrix.bottomRightCorner&lt;p,q&gt;(); 取右下角\\((p,q)\\)大小的矩阵 matrix.topRows(q); matrix.topRows(); 前\\(q\\)行 matrix.bottomRows(q); matrix.bottomRows(); 后\\(q\\)行 matrix.leftCols(p); matrix.leftCols 前\\(q\\)列 matrix.rightCols(q); matrix.rightCols(); 后\\(q\\)列 这上面的函数使用方法和前面类似，这里就不再举例介绍了 向量操作：一维的向量想要取其中某部分数据时，也有对应的操作函数 动态size 固定size 功能 vector.head(n); vector.head(); 取向量前n个元素 vector.tail(n); vector.tail(); 取向量后n个元素 vector.segment(i,n); vector.segment(i); 从i位置开始的n元素块 同理，这里我也不再举例了 矩阵基本运算 这一节，我将讲解一下矩阵的行列式、转置、求逆、四则运算等等 首先是单矩阵的操作 操作 方法 转置 matrix.transpose() 求逆 matrix.inverse() 行列式 matrix.determinant() 迹 matrix.trace() 各元素之和 matrix.sum() 各元素的平方根和 matrix.norm() 各元素的平方和 matrix.squaredNorm() 各元素的平均值 matrix.mean() 矩阵中各元素的最小值/最大值 matrix.minCoeff()/maxCoeff() 按行/列处理 matrix.rowwise()/colwise() 其他操作都比较简单，这里演示一下按行处理 12// 取每一行最大的值（输出为列向量）std::cout &lt;&lt; matrix_10_10.rowwise().maxCoeff() &lt;&lt; std::endl; 然后时矩阵的四则运算，使用符号+-*/即可实现，注意： 加减之间只能在相同大小的矩阵之间进行 除法只能除以数 乘法的规则和矩阵乘法规则相同 矩阵之间操作，只能在相同类型间操作，不能float和double混用 这里为了方便解释，举一个矩阵转化的例子 1234567Eigen::Matrix3d matrix_3d;matrix_3d = Eigen::Matrix3d::Ones();Eigen::Matrix3f matrix_3f;matrix_3f = Eigen::Matrix3f::Ones();// 必须转化后才能进行运算std::cout &lt;&lt; matrix_3d + matrix_3f.cast&lt;double&gt;() &lt;&lt; std::endl; 矩阵特殊操作 这一节，我将讲解一下求解矩阵的特征值、特征向量，解方程等等 首先是特征值，特征向量，和解基础的方程 123456789101112131415161718192021222324252627Eigen::Matrix&lt;double, 10, 10&gt; A = Eigen::MatrixXd::Random(10, 10);A = A * A.transpose(); // 保证A至少是半正定、实对称的（否则后续LLT分解容易出错）Eigen::Matrix&lt;double, 10, 1&gt; b = Eigen::VectorXd::Random(10);// 求特征值和特征向量Eigen::EigenSolver&lt;Eigen::MatrixXd&gt; es(A);std::cout &lt;&lt; &quot;The eigenvalues of A are:&quot; &lt;&lt; std::endl &lt;&lt; es.eigenvalues() &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The matrix of eigenvectors, V, is:&quot; &lt;&lt; std::endl &lt;&lt; es.eigenvectors() &lt;&lt; std::endl &lt;&lt; std::endl;// 求方程Ax=b的解，1.直接求逆（较慢）Eigen::Matrix&lt;double, 10, 1&gt; x1 = A.inverse() * b;std::cout &lt;&lt; &quot;The solution of Ax=b is:&quot; &lt;&lt; std::endl &lt;&lt; x1 &lt;&lt; std::endl &lt;&lt; std::endl;// 2.利用矩阵分解求解（较快），首先是QR分解Eigen::Matrix&lt;double, 10, 1&gt; x2 = A.colPivHouseholderQr().solve(b);std::cout &lt;&lt; &quot;The solution of Ax=b is:&quot; &lt;&lt; std::endl &lt;&lt; x2 &lt;&lt; std::endl &lt;&lt; std::endl;// 3.如果A是正定，可以使用LLT（Lower-Upper Cholesky Decomposition）分解，速度最快Eigen::Matrix&lt;double, 10, 1&gt; x4 = A.ldlt().solve(b);std::cout &lt;&lt; &quot;The solution of Ax=b is:&quot; &lt;&lt; std::endl &lt;&lt; x4 &lt;&lt; std::endl &lt;&lt; std::endl; 有时候，我们要求线性方程的最小二乘解，Eigen中没有对应的函数，不过我们知道\\(Ax=b\\)的最小二乘解为：\\(x=\\left(A^TA\\right)^{-1}A^Tb\\)，所以我们可以自己实现一下： 123456789Eigen::MatrixXd A(4, 2); // 输入矩阵 AA &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8;Eigen::VectorXd b(4); // 输出向量 bb &lt;&lt; 1, 2, 3, 4;Eigen::VectorXd x(2); // 待求解向量 x// 最小二乘求解方程x = (A.transpose() * A).inverse() * A.transpose() * b;std::cout &lt;&lt; &quot;Solution x:\\n&quot; &lt;&lt; x &lt;&lt; std::endl; 计算矩阵的n次方Eigen中也没有对应的实现，不过我们知道\\(A^n=P^{-1}\\Lambda^nP\\)，当然这只在矩阵\\(A\\)可对角化时才可以用（比如实对称矩阵），然后我们就可以通过Eigen实现： 123456789Eigen::Matrix3d A1 = Eigen::Matrix3d::Random();A1 = A1 * A1.transpose(); // 保证A1是实对称Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; eigensolver(A1);auto diag_A = eigensolver.eigenvalues();auto P = eigensolver.eigenvectors();// 计算A^100Eigen::Matrix3d A100 = P * diag_A.array().pow(100).matrix().asDiagonal() * P.transpose(); // 对角化后的A的100次方std::cout &lt;&lt; &quot;A100:\\n&quot; &lt;&lt; A100 &lt;&lt; std::endl; 几何模块 Eigen中有方便进行几何运算的模块，方便我们进行欧式变换等，常用的旋转矩阵、旋转向量、四元数等都可以使用Eigen库中的几何模块进行运算。 定义和初始化 这里我先介绍一下几何中常用的各种变换的定义，包括旋转矩阵、旋转向量、四元数等，其实定义的方式不止如下几种，单常用的就如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;#include &lt;Eigen/Geometry&gt;#include &lt;iostream&gt;int main() &#123; // 定义旋转矩阵 Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::Identity(); // 旋转向量 Eigen::AngleAxisd rotation_vector(M_PI / 4, Eigen::Vector3d(0, 0, 1)); // 欧拉角 Eigen::Vector3d euler_angles(M_PI / 4, M_PI / 2, M_PI / 4); // 欧式变换 Eigen::Isometry3d T = Eigen::Isometry3d::Identity(); T.rotate(rotation_vector); // 按照rotation_vector进行旋转 T.pretranslate(Eigen::Vector3d(1, 3, 4)); // 把平移向量设成(1,3,4) // 四元数 Eigen::Quaterniond q(1, 0, 0, 0); // 顺序为w,x,y,z q = Eigen::Quaterniond(Eigen::Vector4d(0, 0, 0, 1)); // 顺序为x,y,z,w // 仿射变换 Eigen::Affine3d T1 = Eigen::Affine3d::Identity(); T1.rotate(rotation_vector); T1.pretranslate(Eigen::Vector3d(1, 3, 4)); // 射影变换，使用Eigen::Projective3d即可，略 // 打印输出 std::cout &lt;&lt; &quot;rotation_matrix:\\n&quot; &lt;&lt; rotation_matrix &lt;&lt; std::endl; std::cout &lt;&lt; &quot;rotation_vector:\\n&quot; &lt;&lt; rotation_vector.matrix() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;euler_angles:\\n&quot; &lt;&lt; euler_angles &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Transform matrix:\\n&quot; &lt;&lt; T.matrix() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quaternion:\\n&quot; &lt;&lt; q.coeffs() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Affine matrix:\\n&quot; &lt;&lt; T1.matrix() &lt;&lt; std::endl; return 0;&#125; 互相转换 有时候我们还涉及到上述不同类型之间的转换，大部分的转换使用构造函数即可完成转化，但像旋转矩阵之类原始的矩阵需要用对应的函数进行转化： 1234567891011121314151617181920// 旋转矩阵转换为欧拉角Eigen::Vector3d euler_angles1 = rotation_matrix.eulerAngles(2, 1, 0);// 旋转矩阵转换为旋转向量Eigen::AngleAxisd rotation_vector1(rotation_matrix);// 旋转矩阵转换为四元数Eigen::Quaterniond q1(rotation_matrix);// 四元数转换为旋转矩阵Eigen::Matrix3d rotation_matrix3 = q1.matrix();// 旋转向量转换为旋转矩阵Eigen::Matrix3d rotation_matrix4 = rotation_vector1.toRotationMatrix();// 旋转向量转换为四元数Eigen::Quaterniond q2(rotation_vector1);// 四元数转换为旋转向量Eigen::AngleAxisd rotation_vector2(q2);// 欧式变换提取旋转矩阵和平移向量Eigen::Matrix3d rotation_matrix1 = Eigen::Isometry3d(T).rotation();Eigen::Vector3d translation_vector = Eigen::Isometry3d(T).translation();// 仿射变换提取旋转矩阵和平移向量Eigen::Matrix3d rotation_matrix2 = Eigen::Affine3d(T1).rotation();Eigen::Vector3d translation_vector1 = Eigen::Affine3d(T1).translation(); 这里要注意一下欧拉角的转换，Eigen为了防止欧拉角万向锁问题，限制了第一个旋转范围为\\([0,\\pi]\\)，我们在获取欧拉角时，可以用自己的方法计算： 这里其实是欧拉角有冗余性，限制了第一个角的范围后，可以调整第二个角达到和第一个旋转相同的效果，比如yaw=315度，我们可以说欧拉角为\\((135°,180°,180°)\\)，但是大部分情况下，特别是平面机器人运动时，我们要的是\\(roll=0,pitch=0\\)条件下\\(yaw\\)角，所以这里有时候会遇到bug 12345678template &lt;typename T&gt;T GetYaw(const Eigen::Quaternion&lt;T&gt;&amp; rotation) &#123; /* 得到和x轴的夹角 */ const Eigen::Matrix&lt;T, 3, 1&gt; direction = rotation * Eigen::Matrix&lt;T, 3, 1&gt;::UnitX(); /* 计算xoy平面上和x的夹角 */ return atan2(direction.y(), direction.x());&#125; 欧拉角转四元数或者其他旋转变换，可以根据欧拉角和旋转向量的定义完成： 1234/* 可以用旋转向量表示 */q = Eigen::AngleAxisd(ea[0], ::Eigen::Vector3d::UnitZ()) *Eigen::AngleAxisd(ea[1], ::Eigen::Vector3d::UnitY()) *Eigen::AngleAxisd(ea[2], ::Eigen::Vector3d::UnitX()); 运算 由于Eigen进行了大量的运算符重载，除了欧拉角，其他变换都可以用左乘旋转矩阵的规则得到变换后的坐标，如下所示： 123456789101112// 对点进行坐标变换Eigen::Vector3d v(1, 0, 0);// 可以用四种方式进行坐标变换Eigen::Vector3d v_rotated = rotation_matrix * v;Eigen::Vector3d v_rotated1 = rotation_vector * v;Eigen::Vector3d v_rotated2 = q * v;Eigen::Vector3d v_rotated3 = T * v;// 坐标变换之间也能相乘Eigen::Vector3d v_rotated4 = q * (rotation_vector * (rotation_matrix * v));// 可以先算出旋转矩阵，然后用旋转矩阵进行坐标变换Eigen::Matrix3d rotation_matrix5 = (q * rotation_vector * rotation_matrix);Eigen::Vector3d v_rotated5 = rotation_matrix5 * v; 平时的记录 常用的一些量 延z轴的单位向量 (0,0,1)：Eigen::Vector3f::UnitZ() 返回\\([1,0,0]\\) 1Eigen::Vector3f::Identity() 技巧 将laserscan转为pointcloud 1234/* 得到激光角度 */Eigen::AngleAxisf rotation(angle, Eigen::Vector3f::UnitZ());/* 根据距离投影到点上（first_echo为距离） */rotation * (first_echo * Eigen::Vector3f::UnitX()); 参考文档 https://blog.csdn.net/hltt3838/article/details/126330805 https://zhuanlan.zhihu.com/p/36706885 Eigen高阶操作总结 — 子矩阵、块操作_eigen库高级用法-CSDN博客 视觉SLAM14讲","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://thomaszb.cn/categories/C-C/"}],"tags":[]},{"title":"数值分析-误差和迭代","slug":"数值分析","date":"2023-09-25T16:12:05.000Z","updated":"2023-09-25T16:21:05.132Z","comments":true,"path":"2023/09/26/数值分析/","link":"","permalink":"https://thomaszb.cn/2023/09/26/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/","excerpt":"机器人的定位，运动等，和数学显然是无法分开的。如果把研究机器人比作做菜的话，数值分析就是颠锅一样的基本功，没有它能做菜，但做不好菜😶‍🌫️","text":"机器人的定位，运动等，和数学显然是无法分开的。如果把研究机器人比作做菜的话，数值分析就是颠锅一样的基本功，没有它能做菜，但做不好菜😶‍🌫️ 关于这篇博客去年就想开始写了，拖到了现在才开动，不知道上课学的知识还记得多少，就当是复习一下吧😃😃😃 数值分析这门课并没有选上（选的人实在是太多了），不过最后还是一节不落的听完了（除了最后的习题课）。这门课非常有趣且实用，特别是赵熙乐老师上课一边讲解数学原理，一边现场编程演示，利用计算机解决各种数学问题，让我感受到了数学的和编程的之间可以如此和谐。 这个系列不知道要写多久，有空的时候就更新一下吧😊。 不积跬步，无以至千里；不积小流，无以成江海 误差 误差通常是指某一元素的观测值和真值之间的差值，误差有时候很讨厌（不想要误差）有时候却很有用（用于优化得到预测），数值分析从这里开始最好不过了。 误差的衡量 一般情况下，我们把误差分为绝对误差和相对误差，绝对误差的定义如下，很好理解，就代表了一个计算的数值和其真值之间的差距： \\[ e(x) = x-x^* \\] 有时候绝对误差并不能很好的衡量误差的影响，比如0.1的误差对于真值999999和0.2两个数的影响是完全不一样的。而相对误差的作用就体现出来了： \\[ e_r(x)=\\frac{e(x)}{|x^*|} \\] 有时也写作： \\[ e_r(x)=\\frac{e(x)}{|x|} \\] 误差的分类 模型误差：有些问题要用数学方式表达很困难，通常选择一个近似的数学模型，所带的误差为模型误差。 观测误差：物理量的观测通常有误差，很好理解。 截断误差： 通常情况，对于一个复杂的函数，要计算其值，通常是采用近似的方法，比如计算\\(\\ln(2)\\)，我们知道\\(\\ln(x+1)\\)的泰勒展开如下： \\[ ln(x+1)=x-\\frac{1}{2}x^2+\\frac{1}{3}x^3-\\frac{1}{4}x^4+\\cdots+(-1)^{n-1}\\frac{1}{n}x^n+\\cdots \\] 计算\\(ln(2)\\)我们只需把\\(x=1\\)带入上述表达式中，但是由于其泰勒展开无限长，我们显然没法计算其精确解，一般我们会取前面几项。这样由于截断产生的误差就为截断误差。 舍入误差：舍入误差就是指计算机无法精确的表示一个小数引起的误差。 误差有时候会以意想不到的方式捣乱，而有时候一个算法表现不如意却有可能是误差引起的。下面通过讲解计算机中浮点数的误差直观的理解计算机数学和纯数学之间的区别。同时为了更清楚的了解舍入误差，我先介绍一下计算机中小数是如何表示的。 浮点数 计算机做数学运算和现实中的数学运算有点不一样，计算机无法表示连续的量，计算机一般用浮点数表示连续的量，浮点数可以简单的定义如下： 我们想要将一个数\\(f\\)转化为浮点数，首先分别将整数部分和小数部分用二进制表示，再通过右移保证最高位为1（\\(f\\)小于1的时候特殊处理），将尾数M和右移的尾数E保存起来，就得到了浮点数，如下所示： \\[ f=S1.M\\times2^E=S1.ME\\ll E \\] 32位浮点数的标准如下所示： 通常情况下，计算机浮点数的舍入误差为\\(1e-16\\) 误差的传播 举一个简单的误差传播例子，有个方程的迭代形式如下所示： \\[ y_n=1-ny_{n-1} \\] 那么它误差的累积和n之间的关系有：\\(eps_n=n!\\cdot eps_0\\)，我们不断迭代计算上述方程，迭代10次时，误差约为\\(3.6\\times 10^6eps_0\\)，误差被放大了100000倍！而迭代20次后，误差为\\(2.4\\times 10^{19}eps_0\\)！！！ 迭代思想 计算机数学还有一个特点，那就是对于简单的数学运算处理特别快，这带来的好处就是我们可以用一些迭代的算法，通过计算机强大的计算能力不断迭代，从而解决一个复杂的问题。比如我们通过迭代法计算表达式\\(f(x)=0\\)的解，假设解为\\(x^*\\)，计算机通过迭代产生以下序列： \\[ x_0\\rightarrow x_1\\rightarrow x_2\\rightarrow\\dots\\rightarrow x_n\\rightarrow\\dots \\] 只须： \\[ \\lim_{n\\rightarrow\\infty}x_n=x^* \\] 这便是迭代的思想，迭代的思想在计算机中使用非常广泛。 收敛速度 用迭代思想写算法前，必须考虑的一个因素就是收敛速度。为了衡量算法收敛的速度我们定义p阶收敛： 数列p阶收敛 设\\(\\lim\\limits_{n\\rightarrow\\infty}x_n=x^*\\)，若存在\\(a&gt;0, p\\geq0\\)使得 \\[ \\lim\\limits_{n\\rightarrow\\infty}\\frac{|x_{n+1}-x^*|}{|x_n-x^*|^p}=a \\] 则称数列\\(\\{x_n\\}\\)为p阶收敛，特别的有： 收敛阶\\(p=1(a&lt;1)\\)时，称为线性收敛； 收敛阶\\(p&gt;1\\)时，称为超线性收敛； 收敛阶\\(p=2\\)时，称为平方收敛； 序列收敛阶数越高，则收敛速度越快。 收敛的速度也可以用导数来判断，导数和收敛速度的关系如下所示，如果要证明，只需将函数的泰勒展开写出来，带入p阶收敛的定义即可： 定理 设\\(x^*\\)是\\(\\varphi(x)\\)的不动点，且 \\[ \\varphi&#39;(x^*) = \\varphi&#39;&#39;(x^*) = \\dots = \\varphi^{(p-1)}(x^*) = 0\\qquad(\\varphi^{(p)}(x^*) \\neq0 ) \\] 则\\(x_{n+1}=\\varphi(x_n)\\) p阶收敛 二分法 二分法就是通过判断两端中点的值是否满足某个条件，从而舍弃另一半的候选区域。具体怎么实现我这里就不展开讲了，视具体情况而定，是一个比较常见且简单的算法。二分法每次可以降低函数一半的误差，关于二分法，有以下定理： 定理 设\\(x^*\\)是\\(f(x)=0\\)在\\([a_0,b_0]\\)内的唯一根，且\\(f(a_0)f(b_0)&lt;0\\)，则二分过程中，各区间的中点数列 \\[ x_n=\\frac{1}{2}（a_n+b_n)(n=0,1,2,\\dots) \\] 满足 \\[ |x_n-x^*|\\leq\\frac{(b_0-a_0)}{2^{n+1}} \\] 也就是说，如果我们想要最终计算的误差小于\\(0.5\\times 10^{-3}\\)，只需： \\[ \\frac{b_0-a_0}{2^{n+1}}\\leq 0.5\\times 10^{-3} \\] 通常，我们把能容忍的误差称为tolerance(容差)，如果要满足终止准则，即\\(|x_n-x^*|\\leq tolerance\\)，需要的迭代次数为： \\[ n\\geq\\log_2\\frac{b_0-a_0}{tolerance} \\] 不动点迭代 虽然很多人刚开始没听说过这个词，但如果在了解过该算法后，再去接触其他算法，就会惊奇的发现好多算法的思想和不动点迭代完全一致。 首先，我们看一个表达式： \\[ x=(1+x)^{\\frac{1}{2}} \\] 这个表达式在数学上，表示一个方程，其解约为\\(1.618\\)；在程序员眼中，这也可以是一个赋值语句，假如我们给\\(x\\)随便取一个初值，我这里给100，循环执行这个赋值语句，我们可以得到如下结果： 可以看到倒数第二行中，随着迭代次数增加，结果越来越接近\\(1.618\\)，如果循环50次，结果大约为\\(1.61803\\)。可以看到结果和方程的真值越来越接近。是不是所有的方程都满足上述性质呢？显然不是（比如\\(x=x^2\\)），不过上述性质也不是巧合，我们把上述解方程的过程称为不动点迭代，其基本思想是将非线性方程求解化为一些列显示的函数值计算。接下来，我们引入定义： 不动点迭代 \\[ f(x^*)=0\\overset{等价变换}{\\Longleftrightarrow}x^*=\\varphi(x^*)\\Longrightarrow x_n=\\varphi(x_{n-1}) \\] 我们把第二个等式中的\\(x^*\\)称为不动点，如果数列\\({x_n}\\)有极限\\(x^*=\\lim\\limits_{n\\rightarrow \\infty}x_n\\)，则称迭代是收敛的。 tips：最简单的不动点就是在\\(f(x^*)=0\\)两边同时加\\(x^*\\)，得到\\(x^*=f(x^*)+x^*\\) 不同的不动点在迭代时往往表现出来不同的特性，有些不动点不收敛，有些不动点收敛慢。我们该如何判断呢，显然，这些问题早已被前辈们解决，我们只需要知道其定理，并拿来应用即可。 引理一 如果\\(\\varphi(x)\\)在\\([a, b]\\)上具有连续的一阶导数，满足： \\(a\\leq\\varphi(x)\\leq b\\) 对任意的\\(x\\in(a,b)\\)有\\(|\\varphi&#39;(x)|\\leq L&lt;1\\) 则\\(\\varphi(x)\\)在\\([a,b]\\)有唯一的不动点\\(x^*\\) 上述的定理给出了不动点存在的充分条件，可以通过上述引理来判断一些函数是否有不动点。接下来，我们引入全局收敛性定理： 定理一（全局收敛性定理） 如果\\(\\varphi(x)\\)在\\([a, b]\\)上具有连续的一阶导数，满足： \\(a\\leq\\varphi(x)\\leq b\\) 对任意的\\(x\\in(a,b)\\)有\\(|\\varphi&#39;(x)|\\leq L&lt;1\\) 则对任意的\\(x_0\\in[a,b]\\)，迭代格式\\(x_{n+1}=\\varphi(x_n)\\)产生的序列\\({x_n}\\)收敛到不动点\\(x^*\\)，且满足： \\[ |x^*-x_n|\\leq\\frac{L}{1-L}|x_n-x_{n-1}| \\] 上述的定理给出了不动点迭代能够收敛的充分条件。重要的是，根据上述定理，在迭代过程中，我们可以知道我们和真值差距的上界，也就是说该定理可以用来当作收敛条件。 局部收敛定理 设\\(x^*\\)为\\(\\varphi(x)\\)的不动点，\\(\\varphi&#39;(x)\\)在\\(x^*\\)连续，且\\(|\\varphi&#39;(x^*)|&lt;1\\)，则存在\\(x^*\\)的某个邻域对任意\\(x_0\\)属于该邻域，迭代格式\\(x_{n+1}=\\varphi(x_n)\\)产生的序列\\(\\{x_n\\}\\)收敛到不动点\\(x^*\\)。 附录-证明 引理一 存在性证明： 当\\(a=\\varphi(a)\\)或\\(b=\\varphi(b)\\)时，显然成立 当\\(a&lt;\\varphi(a)\\)且\\(b&gt;\\varphi(b)\\)时: 令\\(\\phi(x) = x-\\varphi(x)\\)，有 \\[ \\phi(a) = a-\\varphi(a) &lt; 0\\\\ \\phi(b) = b-\\varphi(b) &gt; 0 \\] 由于\\(\\phi(x)\\)在\\([a, b]\\)内连续，且\\(\\phi(a)\\cdot\\phi(b)&lt;0\\)，则\\(\\exists\\ \\xi\\in(a,b)\\)使得\\(\\phi(\\xi)=0\\)，即\\(\\xi=\\varphi(\\xi)\\) 唯一性证明： 设在\\([a,b]\\)内有两个不动点\\(x_1^*,x_2^*\\)，则有 \\[ |x_1^*-x_2^*|=|\\varphi(x_1^*)-\\varphi(x_2^*)|=|\\varphi&#39;(\\xi)(x_1^*-x_2^*)|=|\\varphi&#39;(\\xi)|\\cdot|x_1^*-x_2^*|&lt;|x_1^*-x_2^*| \\] 显然矛盾，则不肯能存在两个或者以上的不动点。 定理一 收敛性 由 \\(x_0\\in[a,b]\\) ，且在 \\([a,b]\\) 内，有 \\(a\\leq\\varphi(x)\\leq b\\) ，则 \\(x_n\\in[a,b]\\)， 则有： \\[ |x_n-x^*|=|\\varphi(x_{n-1})-\\varphi(x^*)|=|\\varphi&#39;(\\xi)|\\cdot|x_{n-1}-x^*| \\] 则有压缩映像： \\[ |x_n-x^*|\\leq L|x_{n-1}-x^*|\\leq L^n|x_0-x^*| \\] 则有： \\[ \\lim\\limits_{n\\rightarrow\\infty}|x_n-x^*|=0 \\] 收敛上界 \\[ \\begin{eqnarray} |x_n-x^*|=|x_n-x_{n+1}+x_{n+1}-x^*|&amp;\\leq&amp;|x_n-x_{n+1}|+|x_{n+1}-x^*|\\\\ ~&amp;=&amp;|\\varphi(x_{n-1})-\\varphi(x_n)|+|\\varphi(x_n)-\\varphi(x^*)| \\end{eqnarray} \\] \\[ |x_n-x^*|\\leq L|x_{n-1}-x_n|+L|x_n-x^*|\\\\ \\] \\[ (1+L)|x_n-x^*|\\leq L|x_{n-1}-x_n| \\] \\[ |x_n-x^*|\\leq \\frac{L}{(1+L)}|x_{n-1}-x_n| \\] 局部收敛性定理 这个比较容易，我不严谨的证明一下： 由函数的连续性易证，\\(\\exists\\ \\delta\\)，使得在邻域\\(N^0:|x-x^*|\\leq\\delta\\)中，有\\(|\\varphi&#39;(x)|&lt;1\\) 则有，对于\\(\\forall x\\in N^0\\)，即\\(|x-x^*|\\leq\\delta\\)，有\\(|\\varphi(x)-x^*|=|\\varphi(x)-\\varphi(x^*)|\\leq|x-x^*|\\)，即\\(\\varphi(x)\\in N^0\\)。由全局收敛性定理可知，迭代法对\\(\\forall x\\in N^0\\)都收敛 参考 什么是浮点数？ - 知乎 (zhihu.com) 数值计算中误差的基本理论 - 知乎 (zhihu.com)","categories":[{"name":"机器人基础","slug":"机器人基础","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"高仙Lifelong论文解读-适合年轻人读的第一篇Lifelong论文","slug":"高仙Lifelong论文解读-适合年轻人读的第一篇Lifelong论文","date":"2023-07-03T03:45:19.000Z","updated":"2023-07-13T16:14:13.739Z","comments":true,"path":"2023/07/03/高仙Lifelong论文解读-适合年轻人读的第一篇Lifelong论文/","link":"","permalink":"https://thomaszb.cn/2023/07/03/%E9%AB%98%E4%BB%99Lifelong%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-%E9%80%82%E5%90%88%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%AF%BB%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Lifelong%E8%AE%BA%E6%96%87/","excerpt":"介绍高仙的Lifelong SLAM论文，里面也包含这我这段时间对Lifelong的理解。","text":"介绍高仙的Lifelong SLAM论文，里面也包含这我这段时间对Lifelong的理解。 介绍 某位大佬曾经说过，Lifelong主要解决两个问题：long term和large Scale。实际上，对于工厂环境下的机器人来讲，大部分时候没必要考虑Large Scale，显然高仙机器人所用的扫地机器人也是不需要Large Scale的。所以，论文上主要解决的也是long term上面的问题。 高仙的Lifelong SLAM基于经典的SLAM框架，前端定位建图，后端回环检测优化，在上述经典SLAM框架上引入地图更新模块，即可做到Lifelong SLAM。可以发现，和经典SLAM框架的区别在于地图更新模块。普通SLAM会将前端建的地图全部加入全局地图，进行回环检测和优化，而引入地图更新的SLAM，在加入的同时也会检测是否要删除全局地图中的部分子图，从而进行裁剪保证SLAM不会随时间而变大。 而Lifelong SLAM最重要的就在于地图更新的策略，这里高仙的论文也是讲解他们的地图更新策略。 要点提炼 没有变化判断，直接用新图替换旧图 替换时，提取其马尔可夫毯做边缘化 对边缘化后的全连接图用周刘树做稀疏化 很显然，高仙这篇论文的核心在于边缘化和稀疏化，边缘化和稀疏化其实也并不是什么新鲜事，Henrik Kretzschmar等人在2011年就提出了用边缘化和稀疏化来保证SLAM运行的Long term，高仙这篇论文在子图框架下重新介绍了一遍这种方法。 系统介绍 本来是不打算按论文结构介绍的，第一次写论文介绍，没有经验，不过按论文结构介绍好像也能够讲清楚🥺 整体介绍 系统的结构如图所示，可以看到由4个模块构成，其中3个模块都是当前SLAM的通用框架：Pre-Process为预处理，负责得到先验预测位姿；Local LiDAR Odometry为雷达里程计，负责建图和定位；Global LiDAR Matching为后端，负责回环检测和优化。而最后一个模块Pose Graph Refinement为更新模块，负责子图修剪（边缘化）、稀疏化、优化，也就是这篇论文的核心模块。 问题模型 作者将SLAM问题建模为多Session下位姿图的优化问题，所谓的Session可以类比为cartographer下的多轨迹，作者这里的一个Session相当于一天，每个Session都有自己的节点、子图、约束，不同Session间联合优化，优化问题可以看作： \\[ \\mathcal{X}^*,\\mathcal{M}^*=\\arg\\min_{\\mathcal{X},\\mathcal{M}}J(\\mathcal{X}, \\mathcal{M}, \\mathcal{Z}) \\] 其中\\(\\mathcal{X},\\mathcal{M}\\)为节点集合和子图集合，\\(J\\)为代价函数，在本问题中建模为： \\[ \\begin{eqnarray} J(\\mathcal{X}, \\mathcal{M}, \\mathcal{Z})&amp;=&amp;\\left\\|x_0^0\\right\\|_{\\Omega_0}+\\left\\|m^0_0\\right\\|_{\\Omega_0}\\\\ &amp;+&amp;\\sum_{s=0}^{S-1}(\\sum_{i,j}\\left\\|x_i^s\\ominus m_j^{s&#39;}\\ominus z^{mix}_{i^s,j^{s&#39;}}\\right\\|^2_{\\Omega^{mix}_{i^s,j^{s&#39;}}}\\\\ &amp;+&amp;\\sum_{i,j}\\left\\|x_i^s\\ominus x_j^{s&#39;}\\ominus z^{odom}_{i^s,j^{s&#39;}}\\right\\|^2_{\\Omega^{odom}_{i^s,j^{s&#39;}}}\\\\ &amp;+&amp;\\sum_{i,j}\\left\\|x_i^s\\ominus x_j^{s&#39;}\\ominus z^{node}_{i^s,j^{s&#39;}}\\right\\|^2_{\\Omega^{node}_{i^s,j^{s&#39;}}}\\\\ &amp;+&amp;\\sum_{i,j}\\left\\|m_i^s\\ominus m_j^{s&#39;}\\ominus z^{map}_{i^s,j^{s&#39;}}\\right\\|^2_{\\Omega^{map}_{i^s,j^{s&#39;}}}) \\end{eqnarray} \\] 表达式中：\\(x\\)表示节点；\\(m\\)表示地图；\\(z\\)表示观测；节点中右上标表示Session ID，右下标表示节点ID；观测量的右上角表示类型，右下角表示哪两个节点间的观测；表达式中的范数为： \\[ \\left\\|e\\right\\|_\\Omega=e^T\\times\\Omega\\times e \\] 式中第1行为固定点，应该不用管。第二行为回环检测的约束。第三行为激光里程计的约束。第四行为节点间约束，应该是由边缘化产生。第5行为子图间约束，应该由边缘化产生。这样就能将改表达式理清了。 这里所说的节点有时候代表激光关键帧，有时候代表激光关键帧+子图节点。读者（如果有的话🥺）根据实际情况注意区分，应该还是很好理解的。 PGR 这里开始就到了论文的核心模块，作者将其分为Multi-session Localization和Pose Graph Refinement两部分进行介绍，我这里和作者保持一致。 Multi-session Localizaiton 个人感觉这部分的目的在于地图的保存，如果真要做到Lifelong SLAM的话，似乎要不要分Session都无所谓？这一步在我看来似乎有点多余了，当然有可能作者是受到了cartographer轨迹思想的影响。 作者这里使用Session的机制管理节点和子图（类似于Cartographer中的轨迹）。Session 0利用传感器数据构建全局栅格地图，地图由前端构建，每个子图由固定个数的关键帧构成，后端回环检测加优化。 定位从Session 1开始，构建好一个子图后送到PGR进行更新，同时，回环检测的结果也送入PGR。PGR负责接收新子图和约束，进行子图裁剪、位姿图稀疏化、位姿图优化。整体的流程如下图所示： 这里有个关键点：Session 0是不参与更新的，图中其实也可以看出来，不过作者只在后续的实验部分提到了。 Pose Graph Refinement PGR可以翻译成位姿图改进（大概，也许？），他主要的功能就是子图裁剪、稀疏化、优化，前面已经多次提到，这里将分模块介绍。首先，我们可以从图片上略知一二。 如上图所示：图中每个子图有两个节点构成（实际中不可能这么少）；这里删除Session 1的一个子图，如图b所示；通过边缘化删除后，会将位姿图变稠密，如图c；通过周刘树进行稀疏化后可以得到图d；最后结果如图e所示。 子图裁剪 当机器人重新进入之前进入过的区域时，进行子图裁剪，核心思量就是：通过修剪旧子图，限制子图数量。区别于通过探测环境变化再修剪，作者这里采用交叠比例的方法来修剪子图，如果交叠比例大于某个值，就把该子图标记为要修剪得子图。在另一方面新子图的加入是不考虑旧子图的删除的，这种方法能够保证在固定区域内计算的复杂度一致。 位姿图稀疏化 如果采用cartographer那样，直接丢弃子图，会使位姿图丢失很多信息，导致位姿图不稳定。边缘化是缓解该问题的有效方法，但是边缘化却会引入稠密填充（Dense fill-in），如上图c所示，会使计算复杂度上升。作者这里说他们使用周刘树近似独立消除团，这个过程用概率图模型可以表示如下： \\[ \\begin{eqnarray} p(x_1,...,x_n)&amp;=&amp;p(x_1)\\prod_{i=2}^n{p(x_i|x_{i-1},...,x_1)} \\\\ &amp;\\approx&amp;p(x_1)\\prod_{i=2}^n{p(x_i|x_{i-1})}\\\\ &amp;=&amp;q(x_1,...,x_n) \\end{eqnarray} \\] 上述表达式第二行的近似原则是，使得KL散度最小，也就是使得下述表达式最小： \\[ D_{KL}(p||q)=\\int_x{p(x)\\log{\\frac{p(x)}{q(x)}dx}} \\] 得到近似的消除团后，将其合并回原始的位姿图（之前的被删除掉了）。作者在处理消除团时，将所有节点（子图、关键帧）当成相同对象进行处理，所以在处理后会引入node-to-node以及submap-to-submap这类约束。 最开始我对上述的一些概念不太了解，所以说目前还是知识太欠缺了，下面是经过一段学习后对其中一些知识的理解，这里只简单介绍，后续可能单独开博客进行详细介绍 概率图模型：将概率分布中的变量，比如\\(p(x_1,...,x_n)\\)中的\\(x_1,...,x_n\\)看作节点，他们之间如果有依赖关系就看作边，最后用图画出来的模型叫做概率图模型，用概率图模型表示概率分布可以引入计算机图中的一些方法对概率分布进行处理。概率图模型分为有向图模型（贝叶斯网络）和无向图模型（高斯马尔可夫随机场），贝叶斯网络可以很直观的写出其概率分布，马尔科夫随机场通常通过势函数来表示其分布。 团：通常是无向图中的概念，是一个关于节点的集合，节点之间都是连通的。最大团就是添加概率图中其他任何一个变量都不构成团。这里的消除团其实就是一个团，在边缘化过程中会将马尔可夫毯中的变量两两链接，就形成了一个团，通常将其称为消除团。 KL散度：用于衡量两个概率分布的距离。 CLT：对于周刘树，要学明白太难了，不过我再其他论文中看到，在无向图模型中，一个集合的周刘树等于其Kruskal算法的结果（这就是概率引入图的好处吧，虽然不知道原理，但看到Kruskal算法立马能够编写代码，感谢前人的智慧😭）。 优化 优化这里就不多介绍了，就是直接将结果全局优化一次，优化的函数前面模型中有介绍，作者使用的是Google的Ceres优化库进行优化求解。 最后，作者给出了算法的伪代码，如下所示，流程比较简单，一眼就能看明白，复杂点在于函数内部的实现： 总结 可以看出，这篇论文好像讲了很多，但又好像什么都没讲，如果基础知识不够，看了等于没看😭。不过对于入门Long term的思量还是很有帮助的，后面我我将继续跟进其中的一些原理。","categories":[{"name":"机器人","slug":"机器人","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"tags":[]},{"title":"重力对齐推导","slug":"重力对齐推导","date":"2023-06-12T13:55:19.000Z","updated":"2023-07-20T15:52:45.574Z","comments":true,"path":"2023/06/12/重力对齐推导/","link":"","permalink":"https://thomaszb.cn/2023/06/12/%E9%87%8D%E5%8A%9B%E5%AF%B9%E9%BD%90%E6%8E%A8%E5%AF%BC/","excerpt":"在SLAM中，重力可以算是一个非常有用的量，他能为小车提供一个绝对的姿态参考。虽然加速对该向量影响很大，但通过时间平均能够得到一个稳定的重力向量。最近我在思考，将该向量耦合进scan-match的优化函数中，能否解决scan-match在某些环境下性能退化的问题，在耦合进优化函数前，我先参考cartographer推导一下如何使用重力对齐比较合适。","text":"在SLAM中，重力可以算是一个非常有用的量，他能为小车提供一个绝对的姿态参考。虽然加速对该向量影响很大，但通过时间平均能够得到一个稳定的重力向量。最近我在思考，将该向量耦合进scan-match的优化函数中，能否解决scan-match在某些环境下性能退化的问题，在耦合进优化函数前，我先参考cartographer推导一下如何使用重力对齐比较合适。 代码方面开源的仓库能直接看，我这里就用数学的公式进行简单的推导。（图片不知道放什么，就放一张阿梓喵的照片吧o(￣▽￣)ブ） 姿态积分 cartographer并没有直接使用imu出来的姿态，而是在内部自己解算。估计是为了兼容只提供3轴加速度和3轴角速度的IMU。 现在大部分IMU都会内部积分结算出姿态，所以cartographer这一步好像有点多余，即降低精度又浪费算力，实际使用时还是推荐直接使用IMU解算出来的姿态（会不会是某些IMU解算姿态没有重力矫正？）。 姿态解算的原理很容易想到，就是直接对角速度积分更新姿态： \\[ R=\\int_0^t{V_{angle}dt} \\] 这样缺点很明显，没又用到加速度信息（浪费信息就是可耻），且随时间的进行，角度误差累积会越来越大。设想一下，IMU静止，加速度为\\(\\overrightarrow{a}=[0,0,9.8]^T\\)，这时候姿态积分出来告诉你当前姿态是竖着的，这不是搞笑吗🤡。 为了解决上述问题，姿态积分还需要通过重力进行矫正，我们把上述连续积分过程换成离散的迭代相加，那么k-1时刻到k时刻两帧之间坐标变换为： \\[ \\Delta R=V_{angle}\\times \\Delta t \\] 然后更新k时刻的姿态： \\[ R_k=R_{k-1}\\times\\Delta R \\] 因为是内旋（\\(\\Delta R\\)为相较于上一次的增量，也就是以上一次为参考的增量，而不是绝对坐标系），所以这里是左乘。其实用角标格式的坐标变换也很好理解：\\(^w_kR=^w_{k-1}R\\times ^{k-1}_kR\\)，其中\\(^{k-1}_kR\\)就是增量\\(\\Delta R\\) 姿态更行后，显然，加速度也需要更新（加速度是相对于当前IMU姿态的）。这里更新是为了后面指数平均，只有把重力的坐标系变成当前的坐标系，才能和观测数据进行加权。 \\[ \\tilde{\\mathbf{a}}_k=\\Delta R^{-1}\\times\\tilde{\\mathbf{a}}_{k-1} \\] 这里用角标格式的坐标变换也很好理解，我们把各个参考坐标系标出来可以得到：\\(^k\\tilde{\\mathbf{a}}=^k_{k-1}R\\times^{k-1}\\tilde{\\mathbf{a}}\\)，也就是将相对于k姿态的重力变换到相对于k-1参考系的重力向量。 然后就是使用观测的重力更新了。至于为什么不直接使用加速度作为重力向量，实际上使用加速度时，加速度向量上不止重力，还有其他加速度。为了减轻比如加速减速带来的对重力向量的影响，我们通常会对重力的观测量进行指数平均滤波： \\[ {\\mathbf{a}}_k={\\mathbf{a}}_{k-1}+(1-e^{-\\frac{\\Delta t}{\\lambda}})\\overrightarrow{a}_{k} \\] 接下来就是巧妙的地方了，我们根据当前的姿态，可以估计出加速度向量\\(\\tilde{\\mathbf{a}}\\)（假设只有重力加速度），其实就是将z轴旋转到对应的姿态： \\[ \\tilde{\\mathbf{a}}=R_k\\times \\begin{bmatrix}0&amp;0&amp;1\\end{bmatrix}^T \\] 而上面还有一个观测的重力加速度\\(\\mathbf{a}_k\\)，我们可以得到这两个向量的坐标变换（可以直接使用Eigen库的FromTwoVectors函数）： \\[ \\Delta R_{g}=\\left&lt;{\\mathbf{a}}_k,\\tilde{\\mathbf{a}}\\right&gt; \\] 然后将姿态旋转对应的角度，消除累计误差： \\[ \\overline{R}_k=R_k\\times\\Delta R_g \\] 重力对齐的应用 上面IMU的数据得到了，用法有很多，在SLAM中，一般只用他的相对位姿，用于提供初始预测。当然，如果是9轴IMU，理论上是可以直接紧耦合进系统进行优化的（磁力计也可以提供绝对参考，不会有误差累计）。 那么什么是重力对齐呢。我们知道，重力虽然有用，但他却只能提供2个轴的参考。想象一下，任意姿态拿着一个物体，让他绕垂直地球表面的方向转任意角度，得到的重力向量是一样的（本来想画图的，但是3D的图太难画了😭）。 也就是说我们的IMU所提供的观测，只有重力方向算是真正的直观的观测，所谓重力对齐，就是将要匹配的点云（我这里用在SLAM）,转化到重力方向。再移动一个轴去匹配，也就是说，刚开始我匹配需要调整rpy，现在只有调整一个角去匹配，不仅可以提高匹配的精度，还可以降低计算的复杂度。看到这里，相信你会直呼：”我去，还等什么，快给我端上来罢！！！！“。别急，下面就开始介绍。 实际上，重力的方向由于抖动、加速等原因并不一定是准确的（静止的时候应该很准确）。也就是说它是有误差的，在实际使用中，我这里打算的是加一个损失函数再耦合进scan-match的优化函数，得到损失值最小的结果。本来是想写cartographer，但过程较复杂，这里写简化版本（关键步骤）。 首先，需要将激光等数据都转换到tracking坐标系（一般tracking和IMU一致），对于每一个点，我们转化方式如下： \\[ ^{t}P_i=^t_lT\\times ^lP_i \\] 然后就是重力对齐了，先将点云左乘IMU的姿态，得到旋转后的点云： \\[ ^IP_i=^I_tR\\times ^tP_i \\] 该点云就是和IMU重力对齐了的点云，此时旋转点云的yaw角，都能保证得到的重力方向和实际一致。该点云的初始位姿我们也要先来个重力对齐： \\[ ^m_IT=^m_tT\\times ^t_IR \\] 这时候，让\\(^m_IT\\)作为优化变量，得到优化的结果。最后，将结果再转化回去： \\[ ^m_tT=^m_IT\\times ^I_tR \\] 得到匹配的结果。 式中： \\(t\\)：tracking frame \\(l\\)：laser frame \\(m\\)：map frame \\(I\\)：IMU frame","categories":[{"name":"机器人","slug":"机器人","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"tags":[]},{"title":"LIO-SAM激光配准部分推导","slug":"Lio-SAM激光配准部分推导","date":"2023-05-25T15:35:19.000Z","updated":"2023-10-26T15:52:15.458Z","comments":true,"path":"2023/05/25/Lio-SAM激光配准部分推导/","link":"","permalink":"https://thomaszb.cn/2023/05/25/Lio-SAM%E6%BF%80%E5%85%89%E9%85%8D%E5%87%86%E9%83%A8%E5%88%86%E6%8E%A8%E5%AF%BC/","excerpt":"学习下大佬们对高斯牛顿法在实际中的应用o(￣▽￣)ブ","text":"学习下大佬们对高斯牛顿法在实际中的应用o(￣▽￣)ブ 简介 LIO-SAM中，大部分代码都比较好理解，稍微有点麻烦的就是LMOptimization，表面上说是LM优化，但这里其实用的是高斯牛顿优化（优化相关的方法后面会另开博客讲解）。 LM优化相关的原理后面会另开优化博客讲解，这里主要是相当于一个LM优化的应用吧。 推导 下面的推导是我参考一些博客和书籍自己推了一遍，如果看到有错误的地方欢迎指出~ 对于任何一个优化方法，优化前都需要构建其误差函数，这里的误差函数由点到面的距离构成，表达式如下所示： \\[ \\arg\\min_{^M_LT}\\left\\|f(^M_LT)\\right\\|^2_2=\\arg\\min_{^M_LT}\\left\\|\\sum_is_i\\left\\{(\\overrightarrow{n}_i)^Tz_i+D_i\\right\\}\\right\\|^2_2=\\arg\\min_{^M_LT}\\left\\|\\sum_is_ie_i\\right\\|^2_2 \\] 其中\\(z_i\\)为点云在地图的位姿，\\(\\overrightarrow{n}_i=[A,B,C]^T\\)为\\(z_i\\)点云所匹配平面的法向量，\\(^M_LT\\)为Lidar在Map中的位姿，也就是要优化的变量。这里平面方程如下所示，很容易理解，上面的误差函数就是每个点到面的距离加权。 \\[ Ax+By+Cz+D=0 \\] 然后就是\\(z_i\\)的计算，优化变量也存在\\(z_i\\)里面，设\\(\\tilde{z}_i\\)为点云在Lidar坐标系下的位姿，那么\\(z_i\\)的计算公式如下所示： \\[ z_i=^{M}_{L}T\\times\\tilde{z}_i=^M_LR\\times\\tilde{z}_i+^MP_L \\] 其中\\(^M_LR\\)为Map下Lidar的姿态，可以用欧拉角计算（欧拉角只有3个变量方便优化？），众所周知机器人欧拉角一般使用rpy角（可以参考我之前一篇博客）。在LIO-SAM中，这里先将Lidar坐标系转化为相机坐标系，对应关系如下所示： 雷达坐标系和相机坐标系 根据图像可以得到其平移：x-&gt;z，y-&gt;x，z-&gt;y 其旋转的yaw角（Lidar下为rz）：rz-&gt;ry（其他角同理） 我这里直接使用Lidar坐标系推导，不做变换（变换的可以参考这篇博客)。那么可以得到\\(^M_LR\\)的计算公式如下（这里简写成\\(R\\)）： \\[ \\begin{eqnarray} R&amp;=&amp;R_y\\times R_p\\times R_r=R_{rz}\\times R_{ry}\\times R_{rx} \\nonumber \\\\ ~&amp;=&amp;\\begin{aligned}\\begin{bmatrix} crz\\cdot cry&amp;-srz\\cdot crx+crz\\cdot sry\\cdot srx&amp;srz\\cdot srx+crz\\cdot sry\\cdot crx \\nonumber \\\\ srz\\cdot cry&amp;crz\\cdot crx+srz\\cdot sry\\cdot srx&amp;-crz\\cdot srx+srz\\cdot sry\\cdot crx \\nonumber \\\\ -sry&amp;cry\\cdot srx&amp;cry\\cdot crx \\nonumber \\end{bmatrix}\\end{aligned} \\nonumber \\end{eqnarray} \\] 然后就是求雅可比矩阵，根据优化的变量，雅可比矩阵如下所示： \\[ J=\\frac{\\partial{f(^M_LT)}}{\\partial^M_LT}=\\left[\\frac{\\partial e}{\\partial rx},\\frac{\\partial e}{\\partial ry},\\frac{\\partial e}{\\partial rz},\\frac{\\partial e}{\\partial x},\\frac{\\partial e}{\\partial y},\\frac{\\partial e}{\\partial z}\\right]^T \\] 对于求和的雅可比矩阵，我们通常看单个变量\\(e_i\\)，再对其求和，对于单个变量，首先给出对角度\\(rx\\)的偏导： \\[ \\begin{eqnarray} \\frac{\\partial e_i}{\\partial rx}&amp;=&amp;\\overrightarrow{n}_i^T\\cdot\\frac{\\partial z_i}{\\partial rx}=\\overrightarrow{n}_i^T\\cdot\\frac{\\partial^M_LR}{\\partial rx}\\cdot\\tilde{z}_i \\nonumber \\\\ ~&amp;=&amp;\\overrightarrow{n}_i^T\\cdot\\begin{aligned}\\begin{bmatrix} 0&amp;srz\\cdot srx+crz\\cdot sry\\cdot crx&amp;srz\\cdot crx-crz\\cdot sry\\cdot srx \\\\ 0&amp;-crz\\cdot srx+srz\\cdot sry\\cdot crx&amp;-crz\\cdot crx-srz\\cdot sry\\cdot srx \\\\ 0&amp;cry\\cdot crx&amp;-cry\\cdot srx \\end{bmatrix}\\end{aligned}\\cdot\\tilde{z}_i \\nonumber \\end{eqnarray} \\] 然后是对平移\\(x\\)的偏导： \\[ \\begin{eqnarray} \\frac{\\partial e_i}{\\partial rx}&amp;=&amp;\\overrightarrow{n}_i^T\\cdot\\frac{\\partial z_i}{\\partial x}=\\overrightarrow{n}_i^T\\cdot\\frac{\\partial ^MP_L}{\\partial x} \\nonumber\\\\ ~&amp;=&amp;\\overrightarrow{n}_i^T\\cdot\\begin{aligned}\\begin{bmatrix} 1 \\\\0 \\\\0 \\end{bmatrix}\\end{aligned} \\nonumber \\end{eqnarray} \\] 其他偏导求法同理，得到了单个变量的偏导，则雅可比矩阵可以求和得到，得到了雅可比矩阵后，即可计算增量： \\[ H\\Delta x=-g \\] \\[ J^T(x)J(x)\\Delta x=-J^T(x)f(x) \\] 计算出\\(\\Delta x\\)后，不断迭代即可求出Lidar到Map的坐标变换，即Lidar的定位。 我这里写的对\\(J_i\\)求和，实际做时往往是把\\(J\\)排列成一个矩阵\\(J=[J_1,J_2,...J_n]\\)，这样\\(J^TJ\\)其实就相当于进行了一次求和（这种更快？）。 改进 IMU紧耦合 原版的liosam优化到上面就结束了，这里imu并没有采用紧耦合的方式，也就是优化过程中imu并没有提供约束。在实际使用中，某些地方会出现匹配效果不好，定位漂移等情况。为了解决上述问题，我这里根据自己的理解尝试添加imu约束，也就是紧耦合的方式。 添加imu约束前，需要考虑一下使用imu提供的什么约束。很显然，imu提供的约束只有姿态比较准确（高精度的imu），适合作为约束加到优化函数中去。 将imu作为约束加入优化函数中，可以得到优化函数的表达式： \\[ \\arg\\min_{^M_LT}\\left\\|f(^M_LT)\\right\\|^2_2=\\arg\\min_{^M_LT}\\left\\|\\sum_is_ie_i+\\left\\|R_p-^M_LR\\right\\|^2_\\Omega \\right\\|^2_2 \\] 其中\\(R_p\\)为imu相对于上次姿态变化量预测出来的姿态，\\(^M_LR\\)为优化变量中的旋转部分，这里两个变量都为\\(3\\times1\\)向量，即rpy。将其展开可得： \\[ \\left\\|R_p-^M_LR)\\right\\|^2_\\Omega=\\Omega_1\\cdot(rx_p-rx)^2+\\Omega_2\\cdot(ry_p-ry)^2+\\Omega_3\\cdot(rz_p-rz)^2 \\] 其雅可比矩阵可以写作： \\[ J=\\frac{\\partial{f(^M_LT)}}{\\partial^M_LT}=\\frac{\\partial\\left(f_1(^M_LT)+f_2(^M_LT)\\right)}{\\partial^M_LT}=J_{f1}+J_{f2} \\] 其中，\\(J_{f1}\\)为点到面距离的残差部分得到，和上面推导一样，这里不再展开重新推导。\\(J_{f2}\\)为imu约束残差得到，显然，平移部分偏导为0，只有旋转，可以得到如下表达式： \\[ J_{f2}=\\frac{\\partial f_2(^M_LT)}{\\partial^M_LT}=\\left[\\frac{\\partial f_2}{\\partial rx},\\frac{\\partial f_2}{\\partial ry},\\frac{\\partial f_2}{\\partial rz},0,0,0\\right]^T \\] 这里的偏导很简单，我这里给出\\(\\frac{\\partial f_2}{\\partial rx}\\)的计算，其他同理： \\[ \\frac{\\partial f_2}{\\partial rx}=2\\cdot\\Omega_1\\cdot(rx-rx_p) \\] 然后使用高斯牛顿迭代法不断迭代就可以得到最优解。 求和和上面一样，这里为了方便，可以直接在上面所排列的矩阵\\(J=[J_1,J_2,...J_n]\\)后面再添加一个残差项\\(J=[J_1,J_2,...,J_n,J_f2]\\)，同理\\(f(x)\\)也添加一列，就可以简单的将残差添加到前面的表达式中了。 融合重力对齐 还可以使用重力向量试试，即优化出来的姿态可以得到一个重力向量，IMU可以得到一个重力向量，两个之间差值作为残差加入优化。也就是添加一个： \\[ f_3=\\left\\|^m_IR\\times \\begin{bmatrix}0&amp;0&amp;1\\end{bmatrix}^T-\\mathbf{a}\\right\\|^2_\\Omega=\\left\\|R\\times^I_LR\\times\\begin{bmatrix}0&amp;0&amp;1\\end{bmatrix}^T-\\mathbf{a}\\right\\|^2_\\Omega=\\left\\|\\mathbf{\\tilde{a}}-\\mathbf{a}\\right\\|^2_\\Omega \\] 展开后为： \\[ \\Omega_1\\left(\\tilde{a}[0]-a[0]\\right)^2+\\Omega_2\\left(\\tilde{a}[1]-a[1]\\right)^2+\\Omega_3\\left(\\tilde{a}[2]-a[2]\\right)^2 \\] 我们将上面的R带入，可以得到\\(\\mathbf{\\tilde{a}}\\)的表达式： \\[ \\mathbf{\\tilde{a}}= \\begin{bmatrix}crz\\cdot cry\\cdot^I_LR[0][2]+\\left(-srz\\cdot crx+crz\\cdot sry\\cdot srx\\right)\\cdot^I_LR[1][2]+\\left(srz\\cdot srx+crz\\cdot sry\\cdot crx\\right)\\cdot^I_LR[2][2]\\\\ srz\\cdot cry\\cdot^I_LR[0][2]+\\left(crz\\cdot crx-srz\\cdot sry\\cdot srx\\right)\\cdot^I_LR[1][2]+\\left(-crz\\cdot srx+srz\\cdot sry\\cdot crx\\right)\\cdot^I_LR[2][2] \\\\ -sry\\cdot^I_LR[0][2]+cry\\cdot srx\\cdot^I_LR[1][2]+cry\\cdot crx\\cdot^I_LR[2][2] \\end{bmatrix} \\] 对原式求偏导可以得到\\(J_{f3}\\)，老规矩，我这里也只求一个： \\[ \\frac{\\partial f_3}{\\partial rx}=2\\cdot\\Omega_1\\cdot\\left(\\tilde{a}[0]-a[0]\\right)\\cdot\\frac{\\partial \\tilde{a}[0]}{\\partial rx}+2\\cdot\\Omega_2\\cdot\\left(\\tilde{a}[1]-a[1]\\right)\\cdot\\frac{\\partial \\tilde{a}[1]}{\\partial rx}+2\\cdot\\Omega_3\\cdot\\left(\\tilde{a}[2]-a[2]\\right)\\cdot\\frac{\\partial \\tilde{a}[2]}{\\partial rx} \\] 这里求导写出来比较大，原理很简单，我就不在这里写下来了，毕竟还需要根据实际应用重新计算😭。","categories":[{"name":"机器人","slug":"机器人","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"tags":[]},{"title":"FOC从入门到入土","slug":"FOC入门到入土","date":"2023-05-09T15:35:19.000Z","updated":"2023-09-07T15:26:49.446Z","comments":true,"path":"2023/05/09/FOC入门到入土/","link":"","permalink":"https://thomaszb.cn/2023/05/09/FOC%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","excerpt":"菜鸡的FOC踩坑记录/(ㄒoㄒ)/~~","text":"菜鸡的FOC踩坑记录/(ㄒoㄒ)/~~ 前言 FOC简介 FOC即为矢量控制器，具体的介绍可以参考稚晖君的知乎博客【自制FOC驱动器】深入浅出讲解FOC算法与SVPWM技术 - 知乎 (zhihu.com)，我这里就算转行做电控专业也写不这么好的博客，就不在这里献丑了。 我这里主要是记录和分享我在自己使用和编程实现FOC时遇到的问题和理解，博主并不是相关专业的，如文章有疏漏欢迎指出~ 由于自己的无知和贫穷，在尝试做FOC时，Github一搜索，直接选择了成本较低的开源方案miniFOC，这也是我后面所有噩梦的开始。 复刻mini-FOC 由于只给了Gerber文件，为了方便后面对电路进行调整，看原理图也不复杂，我根据原理图自己走线复刻了一版，同时加入了下载口方便后面的调试，硬件电路可以参考我的github链接。 在打样好电路后，就是无刷电机的选型，显然我完全不会选，淘宝无刷电机直接选择了一款，买到手后发现没有磁铁（mini-FOC使用磁编码器），于是网上随便买了一个磁铁，很显然，到这一步电机还是没转起来。 首先便是磁铁的分类，磁编码器的原理如下，是通过磁场来确定当前电机朝向的： 但圆形磁铁根据充磁的不同分为径向充磁和厚度充磁（轴向充磁），厚度充磁NS级在上下，径向充磁才能作为磁编码器的磁铁，如下图所示。 解决磁铁的问题后，在调PID时总是异常抖动，为了解决问题，开始了FOC原理的学习和代码的分析。 无电流环的FOC 首先，遇到的第一个问题就是这款FOC没有电流环，我当时学习原理是根据稚晖君的博客学习，虽说少了电流环理论上方便我分析，但对于当时的我来说，少的电流环对应哪一块，去掉后怎么分析完全不懂，在经过一段时间的摸爬滚打后，才稍微理解了其中的一部分原理。 无电流环意味着什么 在稚晖君的博客里，一开始便分析了电流环，电流环的结构图如下所示，给定Iq和Id的参考，就可以通过电流环实现对电机的精准控制。 电流环是FOC中最内层的环（FOC一般会有位置环、速度环、电流环），他的作用是给电机一个恒定的力矩（力矩是什么的链接），让他转动，而产生的力矩的大小是跟电流相关，而不是电压（高中物理学过的安培力）。根据原理来讲，电流环中的Iq就是控制平行于运动方向的力，而Id是没有用的力，如下图所示，我们的目标就是要让Id为0。 正常情况下，电流和我们设置的电压似乎是等价的（I=U/R），可是电机运动会有反电动势，没有电流环，我们只能保证Ud设置成0，而由于反电动势的存在，真正的Ud=Ud_set+反电动势，显然并不是0，这就是没有电流环的后果，他会让一部分力浪费掉，产生的力不是平行于运动方向的，有部分被白白浪费了，可能会让电机异常抖动，发热等问题。而随着转速提高，反电动势增大，可能导致FOC完全失效。 明白了这个，就知道没有电流环并不是什么大不了的事情，至少没有电流环FOC也能动。接下来，先尝试将电流环去掉，使用简单的SPWM进行分析。明白了这个就知道FOC的控制有多么简单了。 无电流环的SPWM 为什么这里要写SPWM的分析呢？写这种又简单有垃圾的算法还不是因为菜/(ㄒoㄒ)/~~。 将上图的反馈环去掉，SVPWM换成RevCalrk变换，即可得到无电流环的SPWM结构图，如下图所示： 这时候，你可能会问：啊？就这？这也太简单了吧，搞一半天你连这都不懂啊😅？家人们谁懂啊，大无语事件，下头博主这么菜还来写博客！我只能回答：是的，无电流环的SPWM就这么简单QAQ，虽然很简单，但我这里还是简单的讲解一下这几个变换的作用，以及他是如何让电机动起来的。 稚晖君讲解时是直接讲解整个回环的，从反馈开始讲起，我这里没有反馈回路，分析起来就简单多了，我们就可以直接从左到右开始推导。首先要明确一点，我们这里的Vq和Vd分别是设置平行运动方向的电压和垂直运动方向的电压，为了便于理解，可以直接无视掉Vd，默认没有反电动势（没有反馈也只能这样），那么我们需要控制的就只有一个值，即Vq，可以直接把Vq想象成力的大小，也就是圆周运动切向方向力的大小，给定一个Vq就相当于给定一个恒定的切向的力，由于阻力和电机运动速度正相关，电机会先加速（Vq大于阻力），再匀速（Vq等于阻力）。好了，接下来我们开始由Vq向Va，Vb，Vc推导。 首先Vq是一个恒定的力，也就是一维的，只有大小，我们需要先把他转换为矢量形式，也就是既有大小又有方向的力。先直接给出转换的表达式： \\[ V_\\alpha=cos(\\theta)V_q+sin(\\theta)V_d=cos(\\theta)V_q \\] \\[ V_\\beta=-sin(\\theta)V_q+cos(\\theta)V_d=-sin(\\theta)V_q \\] 写成矩阵的形式如下所示： \\[ \\begin{aligned} \\begin{bmatrix} V_\\alpha\\\\ V_\\beta \\end{bmatrix} \\end{aligned} = \\begin{aligned} \\begin{bmatrix} cos(\\theta)&amp;sin(\\theta)\\\\ -sin(\\theta)&amp;cos(\\theta) \\end{bmatrix} \\end{aligned} \\times \\begin{aligned} \\begin{bmatrix} V_q\\\\ V_d \\end{bmatrix} \\end{aligned} \\] 这个变换即Park反变换，表达式中，\\(\\theta\\)为电机转子当前角度，我们要产生垂直与电机转子的力。几何关系如下图所示。 图中绿色箭头为当前电机方向，黄色箭头为希望产生的力矩方向，通过简单的几何计算就可以得到上述的表达式。 然后我们需要将矢量的力分解成3个方向的电压，这是电机实际能产生电压的方向。转换方式如下所示 \\[ \\begin{aligned} \\begin{bmatrix} V_a\\\\ V_b\\\\ V_c \\end{bmatrix} \\end{aligned} =k&#39; \\begin{aligned} \\begin{bmatrix} 1&amp;0\\\\ -\\frac{1}{2}&amp;\\frac{\\sqrt{3}}{2}\\\\ -\\frac{1}{2}&amp;-\\frac{\\sqrt{3}}{2} \\end{bmatrix} \\end{aligned} * \\begin{aligned} \\begin{bmatrix} V_\\alpha\\\\ V_\\beta \\end{bmatrix} \\end{aligned} \\] 这里\\(k&#39;\\)相当于一个系数，他不会影响生成的合力的方向，但会改变合力的大小（显然用三维表示二维有无数种表示方法，这里只是其中一种）。如果要保证合成的电压和实际给的一致，则取\\(k&#39;=1\\)，如果要保证功率一致，则取\\(k&#39;=\\sqrt{\\frac{2}{3}}\\)。这里转换的图我就不画了，和上面同理，简单的脑补一下就可以得到，这样我们就完成了从Vq到Va，Vb，Vc的转换了。 这里还有一个问题，转换过程中大小好像发生了变换，SPWM中，使用占空比来表示电压，也就是Va、Vb、Vc最大为1，最小为0，这时候Vq最大能设置成多少呢？其实在k'=1时，可以很容易推导出来Vq最大值可以设置为1。 无电流环的SVPWM 然后就是SVPWM了，这里分开是因为写博客的时候我还不会SVPWM的推导，这里后面再写/(ㄒoㄒ)/~~ TODO 多极对数的FOC 如果正常情况下，FOC就可以直接使用了，不过这里还有一个概念，我们可以注意到，网上的FOC代码中都有一个可以配置的项目叫电极对数，对于我这样没学过电机的小白来说，该填多少又是一个问题。更进一步，多极对数的FOC和单极对数编程上面有什么区别呢？。好在网上能够找到资料，下面我简单的讲解一下相关概念。 级数与极对数 简单来讲，极数就是电机中永磁体N极和S极的总数。将一个N极加一个S极作为一对磁极，那么极对数=级数÷2，如下图所示，该电机一共有6个级数，3个极对数。 当然，测量极对数时总不能把电机扒开看有几对磁铁吧，通常购买时电机参数会给出，如果是没有给出参数电机可以通过对其中两根线通电，手拨动电机，看一圈一共有几个稳定的点，那就是有几个极对数。 电角度 明确了极对数的概念，接下来就讲解一下多极对数的FOC在编程上面个和普通FOC的区别。 在这里，需要明确一个叫电角度的概念，简单的讲，就是相对与定子，转子磁场旋转的角度。如下图所示，转子转120度，对于定子来说磁场完成了一个周期的变换，所以电角度=转子角度*极对数。 很显然，做控制时我们我们需要用电角度而不是转子角度（机械角度）。转子角度在多极对数已经不能表示当前磁铁的朝向了，显然我们需要生成的磁场需要以电角度为参考才能产生垂直的力矩。 这里举个例子，假设当前机械角度为15度，其实磁场已经转过15*4=60度，需要产生垂直于60度的力矩，如果使用机械角度会使产生的力矩不垂直于电机半径。 有了以上这些概念，加上稚晖君大佬的讲解，才将FOC弄了个一知半解，后面遇到的问题我也会继续更新在该博客上的。 参考文档 【自制FOC驱动器】深入浅出讲解FOC算法与SVPWM技术 - 知乎 (zhihu.com) 无刷直流电机基础知识总结，全！ - 知乎 (zhihu.com) 手撕系列（2）：Clark变换与Park变换 - 知乎 (zhihu.com)","categories":[{"name":"机器人","slug":"机器人","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"tags":[]},{"title":"一些c++好用的三方库","slug":"一些c++好用的三方库","date":"2022-12-20T13:23:19.000Z","updated":"2023-07-13T16:15:16.119Z","comments":true,"path":"2022/12/20/一些c++好用的三方库/","link":"","permalink":"https://thomaszb.cn/2022/12/20/%E4%B8%80%E4%BA%9Bc++%E5%A5%BD%E7%94%A8%E7%9A%84%E4%B8%89%E6%96%B9%E5%BA%93/","excerpt":"c++的库虽然不像python的库一样方便，但谷歌等公司还是出了一些非常好用的三方库，可以大大增加开发效率。","text":"c++的库虽然不像python的库一样方便，但谷歌等公司还是出了一些非常好用的三方库，可以大大增加开发效率。 ProtoBuf 简介 Protobuf提供了一个可扩展的机制，用于序列化结构化的数据，可以方便的在代码中保存数据、读取数据、发送数据。Protobuf类似于JSON，但比JSON更小，更快。Protobuf中可以选择数据的保存方式，通常选择保存成二进制格式，二进制格式相比文本格式更省空间，且读取更快。 protobuf使用上类似于ROS的msg，通过.proto文件定义类型，在c++中直接通过结构体使用。这样的方式方便于跨语言跨平台的消息传递以及文件使用。 创建.proto文件 定义消息类型 首先，直接给出一个简单的.proto文件的示例 1234567syntax = &quot;proto3&quot;;message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 result_per_page = 3;&#125; 第一行为指定使用proto3语法，如果不指定，默认使用proto2。注意：该文件第一行必须为非空 该消息一共有3个字段，每个字段都有一个名字和类型，这里还可以注意到后面等于了一个数字，这个数字为字段编号。 字段类型 字段类型和c语言等差不多，类型名+变量名的方式定义一个变量。 字段编号 消息定义中，每个字段都有一个唯一编号。字段编号用于标识消息在二进制格式中的字段（如前面所示，通常选择将消息保存成二进制），且消息类型使用后不应该改变（改后读取以前的pbstream会出问题）。1-15字段编号占用1个字节，16-2047占用两个字节：频率出现较高的消息元素编号最好不要大于15。具体规则查看参考文档。 字段规则 可以给消息里的每个字段指定一个规则： singular：默认规则，可以有0个或1个该字段 optional：和singular一样，不过可以检查该值是否明确设置（编程时发现这才是默认的？） repeated：该字段可以重复0次或多次 map：如其名 多个消息类型 可以在单个.proto文件中定义多个消息类型： 123456789message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 result_per_page = 3;&#125;message SearchResponse &#123; ...&#125; 注释：这点和c、c++一样，就不过多介绍 保留字段 主要用于版本更新，通过保留删除的字段保证程序不会出现太大错误： 1234message Foo &#123; reserved 2, 15, 9 to 11; reserved &quot;foo&quot;, &quot;bar&quot;;&#125; 默认值 解析消息后，如果读取的编码消息不含特定元素，则会返回默认值，不同类型默认值有所区别： string：空字符串 bytes：空字节 bool：false 数值：0 枚举：默认第一个 message：取决于语言，c/c++中 枚举 首先，来看一个枚举类型使用的举例： 12345678910111213141516enum Corpus &#123; CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7;&#125;message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 result_per_page = 3; Corpus corpus = 4;&#125; 枚举类型使用和c语言中枚举类型差不多，这里要注意的是，第一个元素必须映射到0，即必须有0，0必须是第一个。 同时，还可以对枚举类型赋别名，需要加上选项option allow_alias = true;，如下所示 1234567enum EnumAllowingAlias &#123; option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_STARTED = 1; EAA_RUNNING = 1; EAA_FINISHED = 2;&#125; 导入 有时候，想要将消息分成多个问题，且相互之间可能要使用，就需要用到导入。首先，给出示例： 12345import &quot;myproject/other_protos.proto&quot;;message SearchResponse &#123; repeated Result results = 1;&#125; 如上所示，使用import可以导入其他文件定义的message，然后直接使用。 如果要嵌套导入（A导入B，C导入A，想在C中直接使用B），需要在import是加上public： 123// old.protoimport public &quot;new.proto&quot;;import &quot;other.proto&quot;; 123// client.protoimport &quot;old.proto&quot;;// 这样可以使用old.proto和new.proto，但不能使用other.proto 嵌套 有时候，想要在消息里面定义和使用消息类型（和c++类一样），这时候就需要用到嵌套，首先看一下举例： 12345678message SearchResponse &#123; message Result &#123; string url = 1; string title = 2; repeated string snippets = 3; &#125; repeated Result results = 1;&#125; 要在父消息以外的地方使用此消息，引用方法为Parent.Type： 123message SomeOtherMessage &#123; SearchResponse.Result result = 1;&#125; 更新消息类型 想要在不更改旧代码的条件下创建添加或移除字段，需要符合一下规则： 不能修改现有字段编号 新消息可以用旧代码解析，旧消息也可以用新代码解析，但解析时需要做好默认值判断 移除时最好保留该字段（用reserve），防止未来不小心使用 int32、uint32、int64、uint64 和 bool 都兼容，可以将字段从一种类型更改为另一种类型，而不会破坏向前或向后兼容性（读取和存储时自动转）。 还有很多，具体查看官方文档... 单个类型 可以查看官方文档 可以使用package指定命名空间（c++中） 使用.proto文件生成对应文件 首先需要安装proto文件编译器：https://developers.google.com/protocol-buffers/docs/downloads 然后使用命令行编译，编译命令如下所示： 1protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto 其中SRC_DIR为源文件的目录（可有可无），DST_DIR为生成的目标文件目录，后面跟要编译的.proto文件。最后编译出来一个.h和一个.cc文件。 使用 使用前注意编译，由于使用的proto3，这里可以使用以下方法在cmake中查找和添加对应的include和link选项： 123find_package(Protobuf 3.0.0 REQUIRED)include_directories($&#123;Protobuf_INCLUDE_DIR&#125;)target_link_libraries(write $&#123;Protobuf_LIBRARY&#125;) 然后是api的使用，大部分api在生成的.h文件里面可以找到，以及官方文档中可以找到，这里我给出官方的写入和读取示例。 首先是写入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;addressbook.pb.h&quot;using namespace std;// 根据输入填充person消息void PromptForAddress(tutorial::Person* person) &#123; cout &lt;&lt; &quot;Enter person ID number: &quot;; int id; cin &gt;&gt; id; person-&gt;set_id(id); cin.ignore(256, &#x27;\\n&#x27;); cout &lt;&lt; &quot;Enter name: &quot;; getline(cin, *person-&gt;mutable_name()); cout &lt;&lt; &quot;Enter email address (blank for none): &quot;; string email; getline(cin, email); if (!email.empty()) &#123; person-&gt;set_email(email); &#125; while (true) &#123; cout &lt;&lt; &quot;Enter a phone number (or leave blank to finish): &quot;; string number; getline(cin, number); if (number.empty()) &#123; break; &#125; tutorial::Person::PhoneNumber* phone_number = person-&gt;add_phones(); phone_number-&gt;set_number(number); cout &lt;&lt; &quot;Is this a mobile, home, or work phone? &quot;; string type; getline(cin, type); if (type == &quot;mobile&quot;) &#123; phone_number-&gt;set_type(tutorial::Person::MOBILE); &#125; else if (type == &quot;home&quot;) &#123; phone_number-&gt;set_type(tutorial::Person::HOME); &#125; else if (type == &quot;work&quot;) &#123; phone_number-&gt;set_type(tutorial::Person::WORK); &#125; else &#123; cout &lt;&lt; &quot;Unknown phone type. Using default.&quot; &lt;&lt; endl; &#125; &#125;&#125;// 主函数：根据用户输入的文件，打开或新建，然后写入一个新的personint main(int argc, char* argv[]) &#123; // 验证版本 GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) &#123; cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; ADDRESS_BOOK_FILE&quot; &lt;&lt; endl; return -1; &#125; /* 使用生成的.h文件，创建对应的类 */ tutorial::AddressBook address_book; &#123; // 读取文件 fstream input(argv[1], ios::in | ios::binary); if (!input) &#123; cout &lt;&lt; argv[1] &lt;&lt; &quot;: File not found. Creating a new file.&quot; &lt;&lt; endl; &#125; else if (!address_book.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; &quot;Failed to parse address book.&quot; &lt;&lt; endl; return -1; &#125; &#125; // 添加一个person PromptForAddress(address_book.add_people()); &#123; // 写入文件 fstream output(argv[1], ios::out | ios::trunc | ios::binary); if (!address_book.SerializeToOstream(&amp;output)) &#123; cerr &lt;&lt; &quot;Failed to write address book.&quot; &lt;&lt; endl; return -1; &#125; &#125; // 可选：删除所有的由libprotobuf分配的全局对象 google::protobuf::ShutdownProtobufLibrary(); return 0;&#125; 然后是读取： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &quot;addressbook.pb.h&quot;using namespace std;// Iterates though all people in the AddressBook and prints info about them.void ListPeople(const tutorial::AddressBook&amp; address_book) &#123; for (int i = 0; i &lt; address_book.people_size(); i++) &#123; const tutorial::Person&amp; person = address_book.people(i); cout &lt;&lt; &quot;Person ID: &quot; &lt;&lt; person.id() &lt;&lt; endl; cout &lt;&lt; &quot; Name: &quot; &lt;&lt; person.name() &lt;&lt; endl; /* 判断是否为空字符串（默认值），从而判断是否有email */ if (person.email() != &quot;&quot;) &#123; cout &lt;&lt; &quot; E-mail address: &quot; &lt;&lt; person.email() &lt;&lt; endl; &#125; for (int j = 0; j &lt; person.phones_size(); j++) &#123; const tutorial::Person::PhoneNumber&amp; phone_number = person.phones(j); switch (phone_number.type()) &#123; case tutorial::Person::MOBILE: cout &lt;&lt; &quot; Mobile phone #: &quot;; break; case tutorial::Person::HOME: cout &lt;&lt; &quot; Home phone #: &quot;; break; case tutorial::Person::WORK: cout &lt;&lt; &quot; Work phone #: &quot;; break; &#125; cout &lt;&lt; phone_number.number() &lt;&lt; endl; &#125; &#125;&#125;// 主函数：读取文件，列出所有peopleint main(int argc, char* argv[]) &#123; // 验证版本 GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) &#123; cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; ADDRESS_BOOK_FILE&quot; &lt;&lt; endl; return -1; &#125; tutorial::AddressBook address_book; &#123; // 读取文件 fstream input(argv[1], ios::in | ios::binary); if (!address_book.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; &quot;Failed to parse address book.&quot; &lt;&lt; endl; return -1; &#125; &#125; ListPeople(address_book); // 可选：删除所有的由libprotobuf分配的全局对象 google::protobuf::ShutdownProtobufLibrary(); return 0;&#125; 我这里再记录几个使用过程中总结的api set_xxx 直接设置xxx的值，一般用于int等常见类型的值写入 12tutorial::Person person; person.set_id(id); add_xxx 一般用于reapeat的变量，返回该变量的指针，然后再设置值 12auto* const trajectory_proto = proto.add_trajectory();trajectory_proto-&gt;set_trajectory_id(trajectory_id); mutable_xxx 返回变量的指针，可以直接对其赋值实现修改，一般用于嵌套的结构的修改 12*submap_proto-&gt;mutable_pose() = transform::ToProto(submap_id_data.data.pose); PCL库 PCL里实现了大量的处理点云相关的功能，实现了大量点云相关的通用算法和高效数据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建、可视化等。 CMakeLists 1find_package(PCL REQUIRED QUIET) 基本使用 将激光消息转换为PCL格式 一般SLAM中，激光的格式为sensor_msgs::LaserScan，使用PCL库进行处理前，需要将格式转换为PCL库中表示激光的格式，这里先直接给出转换代码： 1234567891011121314151617181920pcl::PointCloud&lt;pcl::PointXYZ&gt; ConvertScantoPointCloud(const sensor_msgs::LaserScan::ConstPtr &amp;scan_msg) &#123; pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud_points; pcl::PointXYZ point; for (int i = 0; i &lt; scan_msg-&gt;ranges.size(); ++i) &#123; float range = scan_msg-&gt;ranges[i]; if (!std::isfinite(range)) &#123; continue; &#125; if (range &gt; scan_msg-&gt;range_min &amp;&amp; range &lt; scan_msg-&gt;range_max) &#123; float angle = scan_msg-&gt;angle_min + i * scan_msg-&gt;angle_increment; point.x = range * cos(angle); point.y = range * sin(angle); point.z = 0.0; cloud_points.push_back(point); &#125; &#125; return cloud_points;&#125; 通过上述代码就可以得到点云，上述的点云是没有位姿的，相当于中心在原点的激光。其中，定义点云的方式为pcl::PointCloud&lt;pcl::PointXYZ&gt;，其中pcl::PointXYZ表示点的格式。 对点云进行坐标变换 将激光转换为点云时，丢失了点云的坐标信息，要将点云调整到其他地方可以用以下方式实现： 1234// 对点云进行初始化旋转，back_link to front_linkpcl::transformPointCloud(*main_scan_pointcloud_, *main_scan_pointcloud_init_transformed_, transform_martix_); 这里要注意，不管是坐标变换还是进行icp配准，得到的结果都是相对于圆心的，而不是相对于变换前的中心。这里在使用时需要注意。 发布点云 发布点云时，一般会将其转换为ros中的消息格式，代码如下： 1234sensor_msgs::PointCloud2 cloud_msg;pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);cloud_msg.header.frame_id = pointcloud_frame_str_;final_point_cloud_pub_.publish(cloud_msg); 注意 icp使用时需要注意，source和target的定义和ROS中tf有点不一样 123icp.setInputSource (B);icp.setInputTarget (A);icp.align (*C); 上述代码求出来的变换矩阵是\\(_B^AT\\) CSM库 这个主要用来做PL-ICP配准的。 基本使用 点云转换 CSM库中，使用的点云格式为LDP，将ROS中的LaserScan转换为LDP代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041void MultiLidarCalibration::LaserScanToLDP( const sensor_msgs::LaserScan::ConstPtr &amp;scan_msg, LDP &amp;ldp) &#123; unsigned int n = scan_msg-&gt;ranges.size(); // 调用csm里的函数进行申请空间 if (ldp != nullptr) &#123; ROS_INFO(&quot;maybe memory bug&quot;); &#125; ldp = ld_alloc_new(n); for (unsigned int i = 0; i &lt; n; i++) &#123; // calculate position in laser frame double r = scan_msg-&gt;ranges[i]; if (r &gt; scan_msg-&gt;range_min &amp;&amp; r &lt; scan_msg-&gt;range_max) &#123; // 填充雷达数据 ldp-&gt;valid[i] = 1; ldp-&gt;readings[i] = r; &#125; else &#123; ldp-&gt;valid[i] = 0; ldp-&gt;readings[i] = -1; // for invalid range &#125; ldp-&gt;theta[i] = scan_msg-&gt;angle_min + i * scan_msg-&gt;angle_increment; ldp-&gt;cluster[i] = -1; &#125; ldp-&gt;min_theta = ldp-&gt;theta[0]; ldp-&gt;max_theta = ldp-&gt;theta[n - 1]; ldp-&gt;odometry[0] = 0.0; ldp-&gt;odometry[1] = 0.0; ldp-&gt;odometry[2] = 0.0; ldp-&gt;estimate[0] = 0.0; ldp-&gt;estimate[1] = 0.0; ldp-&gt;estimate[2] = 0.0; ldp-&gt;true_pose[0] = 0.0; ldp-&gt;true_pose[1] = 0.0; ldp-&gt;true_pose[2] = 0.0;&#125; 我在项目中，还需要先对点云做坐标变换，再用LDP配准，我这里将点云转换为PCL格式，然后进行坐标变换，再转换为LDP进行配准，PCL转LDP代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637void MultiLidarCalibration::PclToLDP( const pcl::PointCloud&lt;pcl::PointXYZ&gt; &amp;pcl_src, LDP &amp;ldp) &#123; unsigned int n = pcl_src.size(); std::map&lt;float, float&gt; laser_scan; // 调用csm里的函数进行申请空间 ldp = ld_alloc_new(n); /* 对激光按theta排序 */ for (unsigned int i = 0; i &lt; n; i++) &#123; laser_scan.emplace(GetTheta(pcl_src[i]), GetRange(pcl_src[i])); &#125; int i = 0; for (const auto &amp;each_ray : laser_scan) &#123; // 填充雷达数据 ldp-&gt;valid[i] = 1; ldp-&gt;readings[i] = each_ray.second; ldp-&gt;theta[i] = each_ray.first; ldp-&gt;cluster[i] = -1; i++; &#125; ldp-&gt;min_theta = ldp-&gt;theta[0]; ldp-&gt;max_theta = ldp-&gt;theta[n - 1]; ldp-&gt;odometry[0] = 0.0; ldp-&gt;odometry[1] = 0.0; ldp-&gt;odometry[2] = 0.0; ldp-&gt;estimate[0] = 0.0; ldp-&gt;estimate[1] = 0.0; ldp-&gt;estimate[2] = 0.0; ldp-&gt;true_pose[0] = 0.0; ldp-&gt;true_pose[1] = 0.0; ldp-&gt;true_pose[2] = 0.0;&#125; 这里还使用了两个小函数： 123456inline float GetRange(const pcl::PointXYZ &amp;point) &#123; return sqrt(point.x * point.x + point.y * point.y);&#125;inline float GetTheta(const pcl::PointXYZ &amp;point) &#123; return atan2(point.y, point.x);&#125; 注意事项 遇到的bug 做PL-ICP时遇到这个bug 1failed: after trimming, only 0 correspondences. 这是由于忘了设置激光范围导致的，如果不设置激光范围，可能导致所有激光被过滤掉。可以在第一次接收到激光数据时设置： 123456if (!is_reading_range_init_) &#123; is_reading_range_init_ = true; /* 这个非常关键 */ input_.min_reading = in_main_scan_msg-&gt;range_min; input_.max_reading = in_main_scan_msg-&gt;range_max;&#125; gtsam 简介 gtsam是一个因子图优化库，里面实现了不少功能，本来打算另开一篇博客，但目前只使用他的基本功能和边缘化功能，先记录再这里，以后有机会再独立出去。 gtsam优化的原理很简单，基本原理就是求因子图的最大后验分布，在概率图模型中，经常假设节点服从高斯分布，所以最大后验分布很容易证明就是最小二乘解，下面我通过举例的方式简单证明一下。 gtsam优化原理 首先，在SLAM中常用的因子图是基于贝叶斯网络生成的，如下贝叶斯网络： 很显然这里\\(z\\)和\\(x\\)的关系就是观测变量和状态变量的关系，\\(x_1\\)和\\(x_2\\)之间的关系就是里程计的关系： \\[ z_i=f(x_i) \\\\ x_{i+1}=f(x_i) \\] 则对于单个节点，比如\\(z_1\\)、\\(x_2\\)有分布： \\[ z_1=f_1(x_1)+v_1\\\\ x_2=f_2(x_1)+v_2 \\] 其中，\\(v_1\\sim N(0,\\sigma^2)\\)，根据上述表达式可以很容易求出\\(p(z_1|x_1)\\)或\\(p(x_2|x_1)\\)的分布，比如\\(p(z_1|x_1)\\)的分布 \\[ p(z_1|x_1)\\propto exp\\left\\{-\\frac{1}{2}||f(x_1)-z_1||^2_{\\Sigma_k}\\right\\} \\] 将其转换为因子图，这两者如何转换成因子图我就不介绍了，其实就是另一个表达，下图中每一个节点就是一个因子。 则是因子图的概率分布可以写成： \\[ p(x)=\\prod_{i}L(x_i) \\] 其中\\(L(x_i)\\)为因子节点，很显然有关系\\(L(x_1,x_2)\\propto p(x_2|x_1)\\)。对其求MAP： \\[ \\arg\\max_x{\\prod_i{L(x_i)}}\\propto{\\prod_i{exp\\left\\{-\\frac{1}{2}||f(x_1)-z_1||^2_{\\Sigma_k}\\right\\}}} \\] 然后其对数似然函数为（这里每一项其实需要根据实际情况更改）： \\[ \\arg\\min_x{\\frac{1}{2}\\sum_i{||f_i(x_i)-z_i||^2_{\\Sigma_i}}} \\] 很显然，可以看出其MAP和优化的最小二乘是等价的。 gtsam如何得到后验概率分布 优化的原理貌似很简单，但是对于优化后的协方差等是如何求解的还不清楚，后面再详细看。这里用举例的方式介绍一种由因子图计算信息矩阵的方法。 首先，因子图模型如下： 其概率分布可以写做： 将其化简，写成多元高斯分布矩阵形式： 可以得到其中xx就是信息矩阵 说明：这里提到的方法应该不是gtsam内部的实现，gtsam内部的实现目前还没看，这里介绍的只是前段时间看到的一个方法 了解了gtsam的基本原理后，接下来了解一下gtsam的使用 基本使用 使用gtsam边缘化 参考文献 Protobuf： https://developers.google.com/protocol-buffers/docs/proto3 Pcl： https://zhuanlan.zhihu.com/p/334374878 https://pointclouds.org/","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://thomaszb.cn/categories/C-C/"}],"tags":[]},{"title":"verilog基本语法和vivado基本使用","slug":"verilog基本语法和vivado基本使用","date":"2022-09-21T11:24:26.000Z","updated":"2023-07-13T16:10:10.679Z","comments":true,"path":"2022/09/21/verilog基本语法和vivado基本使用/","link":"","permalink":"https://thomaszb.cn/2022/09/21/verilog%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8Cvivado%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"记录一下上课和平时积累的","text":"记录一下上课和平时积累的 语法 verilog的语法相比其他语言比较少，用于描述硬件，要实现功能主要还是模块之间的组合 基本结构和语句要求 每个.v文件就是一个module，代码写再module和endmoudule之间，moudule后跟模块名，以及模块的输入输出，模块内部实现功能。输入输出有两种写法，看自己习惯： 放在括号内 123module a(input a, b, output c, d); ...endmodule 放在括号外 12345module a(a,b,c,d); input a,b; output c,d; ...endmodule 数据类型 parameter：常量 常量位宽和进制设置 1parameter a = 3&#x27;b101 reg：寄存器，主要在时序逻辑电路中，生成出来主要是D触发器 wire：可以理解为线 设置位宽 1reg [3:0] a 逻辑功能描述 assign：如果逻辑能用一句话描述清楚可以使用assign语句 1assign x = (b &amp; ~c) always：如果逻辑比较复杂，使用always块描述 敏感列表：在always @()中的括号里面，也就是该always块触发条件，常见的条件有： posedge：信号上升沿 negedge：信号下降沿 *：所有，一般描述组合逻辑 123456always @(posedge clk) begin // 每当时钟上升沿到来时执行 if (load) out = data; else out = data + 1 + cin; end 关键字 关键字是实现定义好的符号 门结构 and/xand：与/与非 not：非 or/xor：或/或非 buf： 选择结构 if-else结构：综合出来一般带优先级，多级的选择结构 1234if (load) out = data;else out = data + 1 + cin; case结构 casex结构 其他 assign、always、while。。。等等 运算符 运算符 符号 功能 关系运算符 &lt;，&gt;，&lt;=，&gt;=... 和c语言一样 归约运算符和按位运算符 &amp;、^、|、~| 一元运算符，归约运算，所有bit项相与；二元时，按位与 逻辑运算符 !、&amp;&amp;、|| 和c语言一样 位运算符 ~、&amp;、|、^ 和c语言一样 移位运算 &lt;&lt;、&gt;&gt; 和c语言一样 条件运算符 ?: 和c语言一样（一般在assign语句中使用） 位拼接运算符 {,} 实现增长位宽的作用，将多个数据拼接，eg：d = {a, b, c}; 算数运算 +、-、*、/、% 和c语言一样 模块化设计 常用的一些模块往往设计成一个module，其他模块里面可以直接调用，使用方法如下： 写好需要的module 在要用的模块里面实例化：对input和output进行连线，output只能连到wire类型的线上 1234567/* 实例化，将线连接到自己的例程 */ key_filter u_key_filter( // 模块名 .clk (clk) , // 时钟输入信号 .key (key) , // 复位信号，低电平有效 .rst_n (rst_n) , .key_out (key_out)); 如果当前文件是最终的，设置为顶层后再全部编译 技巧 可以把输出定义为wire，赋值使用reg，在外面用assign对wire赋值 同步复位和异步复位： 同步复位：复位信号和时钟同步（复位信号不在敏感列表） 异步复位：只要有reset就复位，不和时钟同步，代码如下所示： 123always @(negedge clk or posedge reset) begin ...end 找到公用电路，尽早实现（如选择） 其他默认规则 if和case语句：最好把所有状态描述完（写全），不然综合会出现锁存器（有些状态没描述，锁存上一次状态） 在always中赋值的变量，一定要定义为reg类型 if-else比switch-case更占空间，没优先级最好用switch-case 组合逻辑中一般用非阻塞赋值，也就是&lt;=赋值 产生触发器不取决于reg，取决于敏感列表negedge clk D触发器的产生，敏感列表有edge，非阻塞赋值时，左边就是Q，右边就是D 常见模块 状态机 状态机可以实现基本所有功能 一般至少两个always块，实现组合和时序 多路复用器Multiplexer 画出原理图 写输入输出 123module Mux8 (input sel, input [7:0] data1, data0, output [7:0] bus1); endmodule 写逻辑 简单的 1assign bus1 = sel ? data1: data0; 复杂的 12345678always @(*) begin case(sel) 0: 1: default: endcase end 其他结构（带优先级的） 代码实现 123456always @(*) begin if(); else if(); else; end 编码器和译码器Encoder/Decoder 确定输入输出关系 代码实现 确定输入输出 1234567module Code42(F, I, en); output [1:0] F; input [3:0] I; input en; reg [1:0] t; assign F = en ? t ： 2‘bz;endmodule; 普通 12345678always @(I) begin case(I) 1: t = 0; 2: t = 1; default: t=0; endcase end 12345678910 * 带优先级的（`if-else`） ```verilog always @ (I) begin if(I[3]) t = 2&#x27;b11; else if(I[2]) t = 2&#x27;b10; else t = 2&#x27;b00; end 带优先级的（switch-case） 12345678always @ (I) begin casex(Data) 3&#x27;b1xx: t = 2&#x27;b11; 3&#x27;b01x: t = 2&#x27;b10; default: t = 2&#x27;bx; endcase end 加法器 写真值表 代码描述 普通 1234module fulladder(input a, b, cin, output sum, cout); assign sum = a ^ b ^ cin; assign cout = (a &amp; b) | (a &amp; cin) | (b &amp; cin);endmodule 知道结构（结构化描述） 123456module Add_half(sum, c_out, a, b); output sum, c_out; input a, b; xor(sum, c, b); and(c_out, a, b);endmodule 用库实现 1234567module Adder4(A, B, Cin, S, Cout); input [3:0] A, B; input Cin; output [3:0] S; output Cout; assign &#123;Cout, S&#125; = A + B + Cin;endmodule 溢出（对有符号的数，判断最高位，也就是符号位是否出错） 12345678module Adder4(A, B, Cin, S, Cout, Ovout); input [3:0] A, B; input Cin; output S; output Cout, Ovout; assign &#123;cout，S&#125; = A + B + Cin; assign Ovout = (A[3]==B[3]) &amp;&amp; (S[3]!=A[3]);endmodule ALU 确定功能（四则运算？） 代码实现 基本 123456789101112131415module ALU8(left, right, mode, ALUout); input [7:0] left, right; input [1:0] mode; output reg [7:0] ALUout; always @(left, right, mode) begin case (mode) 2&#x27;b00: ALUout = A + B; 2&#x27;b01: ALUout = A - B; 2&#x27;b10: ALUout = A &amp; B; 2&#x27;b11: ALUout = A | B; default: ALUout = 8&#x27;bX; endcase endendmodule 触发器 确定功能 代码实现 123456789module Flop (reset, clk, din, qout) input reset, clk, din; output qout; reg qout; always @(negedge clk) begin if (reset) qout &lt;= 1&#x27;b0; else qout &lt;= din; endendmodule 计数器 确定计数器的大小 代码实现 123456789module Counter4 (reset, clk, count); input reset, clk; output [3:0] cout; reg [3:0] cout; always @(negedge clk) begin if (reset) count &lt;= 4&#x27;b00_00; else count &lt;= count + 1; endendmodule 移位寄存器 确定位数 代码实现 D触发器实现 12345678910111213module ShiftReg(A, E, clk, rst); output A; input E, clk, rst; reg B, C, D; always @(posedge clk or posedge rst) begin if (rst) begin A&lt;=0; B&lt;=0; C&lt;=0; D&lt;=0; end else begin A&lt;=B; B&lt;=C; C&lt;=D; D&lt;=E; end endendmodule 通用移位寄存器（移位时，输出可以用bit0和bit7） 1234567891011121314module ShiftRegister8(input s1, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] Parout); always @(negedge clk) begin case (m) 0: ParOut &lt;= ParOut; 1: ParOut &lt;= &#123;ParOut [6:0], sl&#125;; 2: ParOut &lt;= &#123;sr, ParOut [7:1]&#125;; 3: ParOut &lt;= ParIn; default: ParOut &lt;= 8&#x27;bX; endcase endendmodule 序列检测器 确定功能 代码实现 状态机实现 12345678910111213141516171819module Detector (input a, clk, reset, output w); parameter [1:0] s0=2&#x27;b00, s1=2&#x27;b01, s2=2&#x27;b10, s3=2&#x27;b11; // 定义状态 reg [1:0] current, next; always @(posedge clk) begin // 更新状态，时序逻辑 if (reset) current &lt;= s0; else current &lt;= next; end always @(*) begin // 更新激励，组合逻辑 next = s0; // 相当于defalut，覆盖所有情况（高阻之类的） case (current) s0: if (a) next = s1; else next = s0; s1: if (a) next = s2; else next = s0; s2: if (a) next = s2; else next = s3; s3: if (a) next = s1; else next = s0; endcase end assign w = (current == s3) ? 1 : 0; // 输出endmodule 移位寄存器（检测111） moore（输出是同步的） 123456789module Seq_Rec_3_1s_Moore_Shft_Reg(output D_out, input clk, reset, Din, En); reg [2:0] current; always @(posedge clk) begin if (reset) current &lt;= 3&#x27;b000; else if (En) else current &lt;= &#123;Din, current[2:1]&#125;; end assign D_out = (current == 3&#x27;b111) ? 1 : 0;endmodule mealy（输出跟输入有关） 12345678module Seq_Rec_3_1s_Mealy_Shft_Reg(output D_out, input clk, reset, Din); reg [1:0] current; always @(posedge clk) begin if (reset) current &lt;= 2&#x27;b00; else current &lt;= &#123;Din, current[1]&#125;; end assign D_out = ((current==2&#x27;b11) &amp;&amp; Din) ? 1 : 0;endmodule 同步器 功能：将不同时钟域的时钟同步 中间毛刺可能是竞争冒险导致的，一般不需要考虑（glitch） 亚稳态：锁信号时，adata刚好发生改变，解决： 低时钟域到高时钟域 高时钟域到低时钟域（把输入当clk，保证了信号都能采到 实现 普通同步器（采样一次） 12345module Synchronizer (input clk, adata, output reg synched); always @(posedge clk) synched &lt;= adata;endmodule vivado使用 创建工程和添加文件 打开vivado软件，可以看首页的Quick Start，点击Create Project进入创建工程界面 进入后选择路径，进入下一步，选择RTL Project，选择Do not ...（一般建好工程再添加文件） 选择芯片型号后，选择Finish，可以看到如下界面： 综合和分析 在Design Sources中添加源文件，完成代码编写 在右边框的综合中选择Run Synthesis Launch Runs弹窗选择ok即可 Synthesis Completed看情况选择，如果不实施选择View Reports即可 完成后点击综合中的Schematic可以查看原理图 仿真 约束的输入","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://thomaszb.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[],"author":"hang chen"},{"title":"机器人中常用的坐标变换","slug":"机器人中常用的坐标变换","date":"2022-09-21T06:25:17.000Z","updated":"2023-11-02T15:11:10.825Z","comments":true,"path":"2022/09/21/机器人中常用的坐标变换/","link":"","permalink":"https://thomaszb.cn/2022/09/21/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/","excerpt":".center { width: auto; display: table; margin-left: auto; margin-right: auto; } 这篇博客太枯燥了，不想写，放一张yui的照片缓解枯燥吧😊","text":".center { width: auto; display: table; margin-left: auto; margin-right: auto; } 这篇博客太枯燥了，不想写，放一张yui的照片缓解枯燥吧😊 机器人的位姿 其实这篇博客要讲清楚最好结合图片讲解，但作者目前没有合适的画3D坐标系的工具，所以这里很多关系都是用文字的描述。这里还缺少部分的数学推导，如有需要的朋友可以看机器人学导论的第二章（个人感觉讲的比视觉SLAM14讲清楚）。 我们想要了解机器人在空间中的位置，通常给定参考坐标系，以及机器人位置\\(x,y,z\\)即可。当然，这是不考虑机器人姿态的情况下，通常情况下，如果只知道机器人的位置而不知道姿态，基本无法控制机器人。在2D下，通常用\\(x,y,\\theta\\)来表示机器人的位置加姿态。机器人在空间中具体的位置加姿态通常用位姿来表示。也就是 \\[ Pose=Translation+Rotation \\] 位置（Translation）表示通常很简单，下面我直接讲解一下姿态的表示。 旋转矩阵 三维下姿态又很多种表示方式，这里先介绍旋转矩阵（最常用），其他的方式在后面介绍。 在三维空间下，为了更直观的理解物体的姿态，我们在机器人身上放一个右手坐标系（三轴正交），便于观察机器人的姿态变换。现在的问题变成了如何表示这个坐标系的姿态。 由于我这里不考虑位置，那么，我直接将坐标系放到原点便于观察。很容易想到，如果分别将三个轴对应的向量写下来，便能唯一表示一个姿态。把这三个轴的坐标（按列向量）写成矩阵，那么它就是旋转矩阵： \\[ R=(\\overrightarrow{x},\\overrightarrow{y},\\overrightarrow{z})= \\begin{aligned} \\begin{bmatrix} x_1 &amp; y_1 &amp; z_1\\\\ x_2 &amp; y_2 &amp; z_2\\\\ x_3 &amp; y_3 &amp; z_3 \\end{bmatrix} \\end{aligned} \\] 根据上述旋转矩阵的定义，我们不难发现旋转矩阵的几个性质： 旋转矩阵是正交矩阵 如果\\(^A_BR\\)表示A参考系下B的旋转矩阵，那么B参考系下A的旋转矩阵为：\\(^B_AR=^A_BR^T\\) 对于上述第二个性质，如果要证明的话，可以将R矩阵写做内积形式，比如\\(x_1=X_A\\cdot X_B=|X_A|\\cdot|X_B|\\cos&lt;X_A,X_B&gt;\\)，也就是坐标系B在坐标系A下的投影。如果将矩阵中所有元素写成上述形式，可以发现矩阵的行向量为B在A坐标系下\\(\\overrightarrow{x},\\overrightarrow{y},\\overrightarrow{z}\\)的投影，也即性质2所表达的内容。 顺便补充一下，二维右手坐标系下\\(\\theta\\)角姿态对应的旋转矩阵为： \\[ R= \\begin{aligned} \\begin{bmatrix} cos\\theta &amp; -sin\\theta\\\\ sin\\theta &amp; cos\\theta\\\\ \\end{bmatrix} \\end{aligned} \\] 对应的，绕z轴旋转\\(\\theta\\)对应的矩阵为： \\[ R=\\begin{aligned} \\begin{bmatrix} cos\\theta &amp; -sin\\theta &amp; 0\\\\ sin\\theta &amp; cos\\theta &amp; 0\\\\ 0&amp;0&amp;1 \\end{bmatrix} \\end{aligned} \\] 位姿 知道了旋转的表示，我们就可以表示机器人的位姿了。通常情况下，我们把坐标系写在左边，参考坐标系写在左上，而原点写在右下角。比如，我们要表示A坐标系下，B的位姿，就可以： \\[ \\left\\{^A_BR,^AP_{BORG}\\right\\} \\] 其中\\(^A_BR\\)表示B的姿态，\\(^AP_{BORG}\\)表示B原点的坐标。 这样的表示在计算时会带来很大的方便，后面将映射的时候就能体会到了，学会这种表达后，坐标变换有手就行😎 映射 这里有些地方也叫坐标变换，以前我刚学的时候，总是把算子和映射混着用，虽然很多时候表达式通用，但最好还是区分一下。后面的介绍中，注意区分点和坐标系，点是不带姿态的，坐标系是带姿态的，两者搞混淆后阅读起来就不知所云了。 很多时候，我们想要在不同坐标系下表达同一个东西，比如知道小车在里程计坐标系下的位姿，想要得到小车在全局地图坐标系下的位姿，就涉及到坐标的转换，可以说是经常需要用到的。 对于只有平移的映射，我们可以直接用矢量相加的方法求某个点的坐标，比如，已知P点在B坐标系下的坐标，以及A坐标系在B坐标系下的坐标，求P点在A坐标系下的坐标就可以： \\[ ^AP=^BP+^AP_{BORG} \\] 而对于只有旋转，即已知P点在B坐标系下的坐标，以及B坐标系在A坐标系下的旋转，那么我们可以得到点在A坐标系下的旋转： \\[ ^AP=^A_BR^BP \\] 上述表达式通过线性代数的知识很好理解，由于\\(^A_BR\\)的列向量是B坐标系的基向量，上述表达式就是一个坐标变换公式： \\[ ^AP=(\\overrightarrow{e_1},\\overrightarrow{e_2},\\overrightarrow{e_3})\\times\\begin{aligned}\\begin{bmatrix}x\\\\y\\\\z\\end{bmatrix}\\end{aligned}=x\\cdot\\overrightarrow{e_1}+y\\cdot\\overrightarrow{e_2}+z\\cdot\\overrightarrow{e_3} \\] 而对于既有旋转又有平移的变换，要计算B坐标系下的P点在A坐标系下的坐标，我们可以将其分两步：首先通过坐标变换，得到和A相同姿态的A'坐标系下P点的坐标，这时候A'坐标系和B坐标系只有平移关系了，再通过平移得到P再B坐标系下的坐标。即： \\[ ^AP=^A_BR^BP+^AP_{BORG} \\] 上述计算虽然直观，但是在推导表达式时，有时候面对连续多个变换（A到B再到C再到D），如果还用上述变换的方式，写出来的表达式非常复杂，于是人们引入一种叫齐次变换矩阵的概念，其定义如下： \\[ ^A_BT=\\left[\\begin{array}{ccc:c} &amp;^A_BR&amp;&amp;^AP_{BORG}\\\\ \\hdashline0&amp;0&amp;0&amp;1 \\end{array}\\right] \\] 有了其次变换矩阵，我们可以将坐标变换写成矩阵形式： \\[ \\left[\\begin{array}{1}^AP\\\\1\\end{array}\\right]=^A_BT^BP=\\left[\\begin{array}{ccc:c} &amp;^A_BR&amp;&amp;^AP_{BORG}\\\\ \\hdashline0&amp;0&amp;0&amp;1 \\end{array}\\right]\\left[\\begin{matrix}^BP\\\\1\\end{matrix}\\right] \\] &gt;这里面最右边再坐标底下再加一个1的坐标叫做齐次坐标，有时候他和普通坐标会混用，需要根据矩阵自行考虑是否加1 这时候对于多个变换，我们就会惊奇的发现，其上下标消除的特点，比如将C坐标系下的点P变换到B坐标系下，再变换到A坐标系下，就有： \\[ ^AP=^A_BT^B_CT^CP \\] 由于\\(^A_BT\\)和\\(^B_CT\\)都是\\((4\\times4)\\)的矩阵，根据矩阵相乘的结合律，我们可以将其合在一起，而合在一起的这个变换显然直接表示了坐标系C到A的齐次变换矩阵，即： \\[ ^A_CT=^A_BT^B_CT=\\left[\\begin{array}{ccc:c} &amp;^A_BR^B_CR&amp;&amp;^A_BR^BP_{CORG}+{^A}P_{BORG}\\\\ \\hdashline0&amp;0&amp;0&amp;1 \\end{array}\\right] \\] 我们发现，这个过程有点像左边左下角的角标把右上角的角标消掉了，在实际计算各个坐标变换时，我们常用这种方法来帮助理解和简化计算，是不是非常方便😊。对于其次变换矩阵，其逆虽然不再等于转置，但也有快速计算方法： \\[ ^B_AT=^A_BT^{-1}=\\left[\\begin{array}{ccc:c} &amp;^A_BR^{T}&amp;&amp;-^A_BR^T\\times{^A}P_{BORG}\\\\ \\hdashline0&amp;0&amp;0&amp;1 \\end{array}\\right] \\] 算子 简单理解，映射就是一个物体在不同坐标系之间转换，而算子就是在同一个坐标系下，将P点移动到P'点的变换矩阵。 有时候我们要移动一个点，比如让激光点云旋转10°，或者让激光点云向前平移10cm，这时候怎么做呢？这样的操作和变换有什么关系呢？直接说结论：包含旋转R和平移Q的变换与描述某个坐标系旋转R并平移Q的变换是相同的。 首先考虑简单的平移，将点P向前移动\\(x\\)，其移动后的坐标为： \\[ P&#39;=P+\\begin{bmatrix}x\\\\0\\\\0\\end{bmatrix} \\] 显然，这和坐标系B在坐标系A前面\\(x\\)的平移变换是一致的。 然后考虑旋转，将P点绕Z轴旋转\\(\\theta\\)，那么旋转后的P点位置如何计算呢？我们可以使用映射的方法计算，思考一下，如果将P点绕Z轴旋转\\(\\theta\\)，就相当于把坐标轴旋转\\(-\\theta\\)，假设原始坐标系是A，旋转后新坐标系为B，那么我们就可以将上述过程转化为计算B坐标下P点的坐标，首先计算旋转矩阵\\(^B_AR\\)，即B为参考坐标系下A坐标系的姿态： \\[ ^B_AR=\\begin{aligned} \\begin{bmatrix} cos\\theta &amp; -sin\\theta &amp; 0\\\\ sin\\theta &amp; cos\\theta &amp; 0\\\\ 0&amp;0&amp;1 \\end{bmatrix} \\end{aligned} \\] 可以得到旋转\\(\\theta\\)后P点的坐标为： \\[ P&#39;=R\\times P=^B_AR\\times P \\] 也就是说，旋转也满足上述结论，将旋转和平移结合一下，那么就可以得到我最开始得到的结论🫡 绕固定轴旋转 绕一个固定轴旋转的旋转矩阵经常使用，我这里记录一下绕不同轴旋转得到的矩阵（实际上根据旋转矩阵的定义也能很快确定），方便后面参考使用。 下面的表达式中使用简写\\(crx\\)代表\\(\\cos(\\theta_x)\\)，也就是x轴方向旋转\\(\\theta_x\\)的\\(\\cos\\)值，\\(srx\\)同理。 绕x轴旋转得到的旋转矩阵： \\[ R_{rx}= \\begin{aligned} \\begin{bmatrix} 1&amp;0&amp;0\\\\0&amp;crx&amp;-srx\\\\0&amp;srx&amp;crx \\end{bmatrix} \\end{aligned} \\] 绕y轴旋转得到的旋转矩阵： \\[ R_{ry}=\\begin{aligned}\\begin{bmatrix}cry&amp;0&amp;sry\\\\0&amp;1&amp;0\\\\-sry&amp;0&amp;cry\\end{bmatrix}\\end{aligned} \\] 绕z轴旋转得到的旋转矩阵： \\[ R_{rz}=\\begin{aligned}\\begin{bmatrix}crz&amp;-srz&amp;0\\\\srz&amp;crz&amp;0\\\\0&amp;0&amp;1\\end{bmatrix}\\end{aligned} \\] 欧拉角和旋转向量 上面讲了这么多，相信大家都觉得挺简单的，自己映像中好像没这么简单吧(・∀・(・∀・(・∀・*)，印象中好像还有什么左手坐标系，右手坐标系、雷达坐标系、相机坐标系、内旋、外旋、X-Y-Z、rpy...什么的。这部分可以说是新手的噩梦😰，让人闻风丧胆。不过不要担心，某奥里给曾经说过，战胜恐惧的最好办法就是面对恐惧，干就完了，奥里给！！！！ 学会了上一章节，相信代码中的各种变换能轻而易举的看懂，毕竟不管是Eigen库还是ros的tf库，其都支持上述的乘法形式的坐标变换，但很多时候，我们为了图方便并不喜欢用矩阵来表达姿态。比如有人问你相机姿态是多少，相信没人想听别人说出一个旋转矩阵。而欧拉角就解决了这一痛点。当然，四元数是解决了欧拉角的痛点。 坐标系 首先，要声明一点的就是，坐标系放在这里讲，表明上述的旋转矩阵在所有坐标系下都是通用的。不管坐标系是左手，右手，x轴朝前等等，绕z轴得到的旋转矩阵都是上面所提到的旋转矩阵，不过由于坐标系的定义不同，旋转出来的物理（实际）效果可能完全不同。 坐标系这里放一小章讲并不是因为它内容多，而是因为它很容易让新手（比如当初的我）混淆。这里介绍一些常用的坐标系： 左/右手坐标系 左右手坐标系的定义如下图所示，大拇指指向z轴，其余四指由x轴握向y轴，哪只手成功即为对应的坐标系： Lidar坐标系 Lidar坐标系一般如下图所示，即x轴朝前的右手坐标系： 相机坐标系 相机坐标系一般如下图所示，即z轴朝前的右手坐标系： 这里所谓的超前就是正放，比如雷达正放和相机正放。 Lidar坐标系转相机坐标系 很显然，由上面可知，Lidar坐标系和相机坐标系是不一样的，如果两个传感器都正放在车上，要对Lidar和相机的参数做联合优化时，往往需要把Lidar坐标系转换到相机坐标系，根据上图关系可以知道，如果一个点云的坐标为\\((x,y,z)\\)，那么将他转化到相机坐标系，他的坐标为\\((y,z,x)\\)。 同时，绕不同轴转的角度也需要对应的转换，比如绕x轴转rx，对应到相机坐标系为绕z轴转rx。这里需要结合后面欧拉角看。 欧拉角 这部分非常绕，我下面讲解的东西虽然在某些情况下好像能用，但是换一个环境好像又对不上了，感觉不同的教材，不同的软件定义不同，使用时还是要注意以下，不过大体上是对的 欧拉角的思想很简单，将空间中任意一个姿态分解成3个顺序旋转（也就是说按照规则转3次后得到姿态）。这样就可以用3个变量表示空间中任意姿态了。根据旋转的规则不同，欧拉角的值也有所不同。由于欧拉角按顺序旋转，旋转的方式有很多种，可以按下分类： 绕固定轴旋转（外旋）：X-Y-Z，Z-X-Y... 绕旋转后的轴旋转（内旋）：X-Y-Z，Z-X-Y... 举个例子，Z-Y-X外旋，就是先绕Z轴转，再绕Y轴转，最后X轴转，这里面的xyz轴是固定的。而Z-Y-X内旋就是绕Z轴转后，绕旋转后坐标系的Y轴转下一次。朋友们可以拿身边的物体试一下，这两种转法是不一样的。通常情况下，绕固定轴旋转，每次旋转都是左乘旋转矩阵，这点和我们之前讲的算子一样，比如绕Z轴转\\(R_z\\)，再绕Y轴旋转\\(R_y\\)，最后绕X轴旋转\\(R_x\\)，其旋转矩阵为： \\[ R=R_x\\times R_y\\times R_z \\] 而内旋都是右乘旋转矩阵，所以内旋Z-Y-X和外旋X-Y-Z得到的旋转矩阵相同（也可以自己用物体试验一下，真是难以理解呢，太神奇了）。上述的旋转顺序如果是内旋，得到的旋转矩阵为： \\[ R=R_z\\times R_y\\times R_x \\] 对于不同的旋转方式，所对应的运算也不相同。为了便于讨论，在机器人领域中，我们常用rpy角，rpy角是一种特殊的欧拉角，其规则为：旋转顺序：Y-P-R，或则说是Z-Y-X（不一定？跟坐标系定义有关），绕旋转后的轴旋转（内旋）。我这里参考的是视觉SLAM14讲上的定义，同时，我注意到网上有很多跟其定义的不一样，使用时注意区分。 需要注意的是，机器人领域中的rpy角一般是指在Lidar坐标系下的旋转，如果是相机坐标系下，旋转顺序需要做一定的转化。 rpy角和旋转矩阵的转换方式如下（我这里的zyx是对应于lidar的，相当于z在上x向前的右手坐标系，对于不同的坐标系得到的结果也不同） \\[ \\begin{eqnarray} R&amp;=&amp;R_{yaw}\\times R_{pitch}\\times R_{roll}=R_{rz}\\times R_{ry}\\times R_{rx}\\\\ &amp;=&amp;\\begin{bmatrix}crz\\cdot cry&amp;-srz\\cdot crx+crz\\cdot sry\\cdot srx&amp;srz\\cdot srx+crz\\cdot sry\\cdot crx\\\\srz\\cdot cry&amp;crz\\cdot crx+srz\\cdot sry\\cdot srx&amp;-crz\\cdot srx+srz\\cdot sry\\cdot crx\\\\-sry&amp;cry\\cdot srx&amp;cry\\cdot crx\\end{bmatrix}\\end{eqnarray} \\] 对于不同坐标系，比如相机坐标系（z朝前的右手坐标系），yaw角对应的就是\\(R_{ry}\\)。总之公式前半部分一定是对的，后半部分根据坐标系不同需要注意一下。同时，这里是内旋，所以旋转对应右乘。 到这里，我们就把欧拉角介绍清楚了，虽然表面上把变量从9个减少到了3个，但却更容易混淆了，旋转矩阵只需要给定坐标系、旋转矩阵两个量就能唯一确定一个旋转，而欧拉角需要坐标系、旋转顺序、内旋/外旋、旋转角度才能唯一确定一个旋转，可以说是真让人头大。那么有没有什么方法既可以减少变量，由不容易混淆（没有奇异）呢。下面介绍四元数。 &gt;其实这里还有一个问题，就是如何从旋转矩阵得到欧拉角，做法其实不复杂，根据上述转换关系，通过矩阵内部元素之间的乘除法可以得到对应欧拉角的正弦、余弦、正切值等，然后通过反三角计算即可 旋转向量 旋转向量在求导时经常用到相关概念，以我目前的认知来看，我认为是旋转向量和梯度很像，他既有方向，又有大小，即像内旋一样取决于当前姿态，又没有各种歧义。这部分在后面的李群和李代数中非常有用 简单来讲，旋转向量就是一个向量，向量的方向表示旋转轴，向量的大小表示旋转角度，通常用符号\\(\\phi\\)表示。为了后面便于理解，需要先引入一些概念，首先是外积： \\[ \\pmb{a}\\times \\pmb{b}=\\begin{aligned}\\begin{bmatrix}a_2b_3-a_3b_2\\\\a_3b_1-a_1b_3\\\\a_1b_2-a_2b_1\\end{bmatrix}\\end{aligned}=\\begin{aligned}\\begin{bmatrix}0&amp;-a_3&amp;a_2\\\\a_3&amp;0&amp;-a_1\\\\-a_2&amp;a_1&amp;0\\end{bmatrix}\\end{aligned}\\pmb{b}=\\pmb{a}^{\\wedge}b \\] 这里和普通外积一样，主要是引入一个符号\\(\\wedge\\)，将该符号称为反对称符号，他的功能是将向量转成对应的一个反对称矩阵，还有一个符号\\(\\vee\\)表示将对应的反对称矩阵转化为向量，这是一个一一对应的关系： \\[ \\pmb{a}^{\\wedge}=\\begin{aligned}\\begin{bmatrix}0&amp;-a_3&amp;a_2\\\\a_3&amp;0&amp;-a_1\\\\-a_2&amp;a_1&amp;0\\end{bmatrix}\\end{aligned} \\] 一个旋转向量可以唯一表示一个姿态，那么他对应了一个旋转矩阵，将旋转向量分解为模乘以方向的形式\\(\\phi=\\theta\\pmb{n}\\)，那么旋转向量和旋转矩阵的关系由罗德里格斯公式给出： \\[ R=\\cos\\theta I+\\left(1-\\cos\\theta\\right)\\pmb{n}\\pmb{n}^T+\\sin\\theta\\pmb{n}^{\\wedge} \\] 同样，旋转矩阵也可以转化成旋转向量，对上述罗德里格斯公式两边同时取迹可以得到： \\[ \\theta = \\arccos\\frac{tr{(R)}-1}{2} \\] 而根据旋转轴旋转后不变可得\\(R\\pmb{n}=\\pmb{n}\\)可得：旋转轴为\\(R\\)中特征值1对应得特征向量，根据本科求特征值特征向量得方法的知识即可求出 &gt; 这里还是简单说一下，根据\\(\\left(A-\\lambda E\\right)x=0\\)，先求\\(\\lambda\\)再带入求解\\(x\\)，不过这里\\(\\lambda=1\\)是已知结果，可以带入后直接求解对应的\\(x\\) 四元数 如果说欧拉角是最容易混淆的，那么四元数就是最难理解的😭。 有一些复数基础的朋友都知道复数乘以\\(e^{i\\theta}\\)就是将复数在复平面旋转\\(\\theta\\)（我本科做图片旋转的作业时，就是将每个点转化成复数，再乘以\\(e^{i\\theta}\\)得到旋转后的像素坐标）。而四元数就相当于三维空间上的复数，我们先介绍以下四元数的基本概念和性质，再使用他来表示姿态。 四元数基本概念和性质 四元数一般用符号\\(q\\)（quaternion）表示，拥有一个实部和三个虚部，如下所示（实部不一定在前面）： \\[ \\pmb{q}=q_0+q_1i+q_2j+q3k \\] 其中，\\(i,j,k\\)为虚部，他们之间满足： \\[ \\left\\{\\begin{align*}\\begin{array}{l}i^2=j^2=k^2=-1\\\\ij=k,ji=-k\\\\jk=i,kj=-i\\\\ki=j,ik=-j\\end{array}\\end{align*}\\right. \\] 通常情况下，我们喜欢用一个标量和一个向量来表示四元数： \\[ \\pmb{q}=\\left[s,\\pmb{v}\\right]^T,\\ s=q_0\\in R,\\ \\pmb{v}=\\left[q_1,q_2,q_3\\right]^T\\in R^3 \\] 如果一个四元数实部为0，称为虚四元数，若虚部为0，则称为实四元数，接下来讲解一下四元数的运算，设有两个四元数： \\[ \\pmb{q}_a=\\left[s_a,\\pmb{v}_a\\right]=s_a+x_ai+y_aj+z_ak \\\\ \\pmb{q}_b=\\left[s_a,\\pmb{v}_a\\right]=s_a+x_ai+y_aj+z_ak \\] 四元数加减法 \\[ \\pmb{q}_a\\pm\\pmb{q}_b=\\left[s_a\\pm s_b,\\pmb{v}_a\\pm\\pmb{v}_b\\right] \\] 乘法 \\[ \\begin{align*} \\pmb{q}_a\\pmb{q}_b=&amp; s_as_b-x_ax_b-y_ay_b-z_az_b\\\\ &amp;+\\left(s_ax_b+x_as_b+y_az_b-z_ay_b\\right)i\\\\ &amp;+\\left(s_ay_b-x_az_b+y_as_b+z_ax_b\\right)j\\\\ &amp;+\\left(s_az_b+x_ay_b-y_ax_b+z_as_b\\right)k \\end{align*} \\] 这里其实就是两数相乘的结果，写法上，上式是保证左边字母顺序是\\(s_a,x_a,y_a,z_a\\)，右边就是乘积为对应维度的值，写成向量的形式有 \\[ \\pmb{q}_a\\pmb{q}_b=\\left[s_as_b-v_a^Tv_b,s_av_b+s_bv_a+v_a\\times v_b\\right]^T \\] 根据上面所示，显然实四元数相乘仍未实四元数、虚四元数相乘认为虚四元数，且四元数的乘法不满足交换律 模长 \\[ \\left\\|\\pmb{q}_a\\right\\|=\\sqrt{s_a^2+x_a^2+y_a^2+z_a^2} \\] 两个四元数乘积的模等于模的乘积： \\[ \\left\\|\\pmb{q}_a\\pmb{q}_b\\right\\|=\\left\\|\\pmb{q}_a\\right\\|\\left\\|\\pmb{q}_b\\right\\| \\] 共轭 和复数一样，共轭就是虚部取相反数： \\[ \\pmb{q}_a^*=s_a-x_ai-y_aj-z_ak=\\left[s_a,-\\pmb{v}_a\\right]^T \\] 和复数一样，四元数和自身共轭的乘积为模长的平方： \\[ \\pmb{q}_a^*\\pmb{q}_a=\\pmb{q}_a\\pmb{q}_a^*=\\left[s_a^2+\\pmb{v}_a\\pmb{v}_a^T, 0\\right] \\] 逆 其实就是\\(1/\\pmb{q}\\)，和复数类似，可以上下同时乘以共轭得到： \\[ \\pmb{q}^{-1}=\\frac{\\pmb{q}^*}{\\left\\|q\\right\\|^2} \\] 显然，其逆和自身乘积为1： \\[ \\pmb{q}^{-1}\\pmb{q}=\\pmb{q}\\pmb{q}^{-1}=1 \\] 如果\\(q\\)为单位四元数，其逆等于共轭，四元数乘积的逆具有和矩阵类似的性质： \\[ \\left(\\pmb{q}_a\\pmb{q}_b\\right)^{-1}=\\pmb{q}_b^{-1}\\pmb{q}_a^{-1} \\] 数乘 \\[ k\\pmb{q}=\\left[ks,k\\pmb{v}\\right] \\] 四元数表示旋转 这里我主要讲解一些公式，没有几何上的解释 使用四元数表示的旋转 首先，我们需要记住一点，一个单位四元数对应了一个唯一的旋转，如果将该旋转作用在\\(\\pmb{p}\\)点上，让其变成\\(\\pmb{p}&#39;\\)需要两步： 首先用虚四元数表示空间中的\\(\\pmb{p}=[x,y,z]\\)点 \\[ \\pmb{p}=[0,x,y,z]^T=[0,\\pmb{v}]^T \\] 旋转后的点为 \\[ \\pmb{p}&#39;=\\pmb{q}\\pmb{p}\\pmb{q}^{-1} \\] 这里旋转后的为纯虚四元数，其虚部为旋转后的点的坐标 和其他旋转的关系 为了和旋转矩阵扯上关系，我们先定义两个符号，用于将四元数转化成矩阵，设\\(\\pmb{q}=[s,\\pmb{v}]^T\\)，定义符号\\(^+\\)和\\(^{\\bigoplus}\\)为： \\[ \\pmb{q}^+=\\begin{aligned}\\begin{bmatrix}s&amp;-\\pmb{v}^T\\\\\\pmb{v}&amp;s\\pmb{I}+\\pmb{v}^{\\wedge}\\end{bmatrix}\\end{aligned},\\ \\pmb{q}^{\\bigoplus}=\\begin{aligned}\\begin{bmatrix}s&amp;-\\pmb{v}^T\\\\\\pmb{v}&amp;s\\pmb{I}-\\pmb{v}^{\\wedge}\\end{bmatrix}\\end{aligned} \\] 有了上述符号，我们可以把四元数乘法写成矩阵的形式： \\[ \\pmb{q}_1^+\\pmb{q}_2=\\begin{aligned}\\begin{bmatrix}s_1&amp;-\\pmb{v}_1^T\\\\\\pmb{v}_1&amp;s_1\\pmb{I}+\\pmb{v}_1^{\\wedge}\\end{bmatrix}\\end{aligned}\\begin{aligned}\\begin{bmatrix}s_2\\\\v_2\\end{bmatrix}\\end{aligned}=\\begin{aligned}\\begin{bmatrix}-\\pmb{v}_1^T\\pmb{v}_2+s_1s_2\\\\s_1\\pmb{v}_2+s_2\\pmb{v}_1+\\pmb{v}_1^{\\wedge}\\pmb{v}_2\\end{bmatrix}\\end{aligned}=\\pmb{q}_1\\pmb{q}_2=\\pmb{q}_2^{\\bigoplus}\\pmb{q}_1 \\] 我们就可以写出四元数和旋转矩阵的关系（证明见最后）： \\[ \\pmb{R}=\\pmb{v}\\pmb{v}^T+s^2\\pmb{I}+2s\\pmb{v}^{\\wedge}+\\left(\\pmb{v}^{\\wedge}\\right)^2 \\tag{1} \\] 有了R，就可以很容易得到和旋转向量之间的关系（证明见最后）： \\[ \\left\\{\\begin{align*}\\begin{array}{l} \\theta = 2\\arccos q_0\\\\ \\left[n_x,n_y,n_z\\right]^T=\\left[q_1,q_2,q_3\\right]^T/\\sin\\frac{\\theta}{2} \\end{array}\\end{align*}\\right.\\tag{2} \\] 其他变换 除了上述欧式变换之外，常见的还有如下3种变换 相似变换 相比欧式变换多了一个自由度，可以对物体进行均匀缩放 \\[ \\begin{aligned}\\begin{bmatrix}s\\pmb{R}&amp;\\pmb{t}\\\\\\pmb{0}^T&amp;1\\end{bmatrix}\\end{aligned} \\] 仿射变换（正交投影） 形式如下所示： \\[ \\begin{aligned}\\begin{bmatrix}\\pmb{A}&amp;\\pmb{t}\\\\\\pmb{0}^T&amp;1\\end{bmatrix}\\end{aligned} \\] 仿射变换只要求矩阵\\(\\pmb{A}\\)为可逆矩阵，而不必须是正交矩阵，放射变换后立方体不一定是方的，单各个面仍然平行 射影变换 形式如下所示： \\[ \\begin{aligned}\\begin{bmatrix}\\pmb{A}&amp;\\pmb{t}\\\\\\pmb{a}^T&amp;v\\end{bmatrix}\\end{aligned} \\] 左上角为可逆矩阵\\(\\pmb{A}\\)，右上角为平移\\(\\pmb{t}\\)，左下角为缩放\\(\\pmb{a}\\)，右下角的\\(v\\)其实只有1和0两种取值（其他值时可以对矩阵除以\\(v\\)转化成1），这里左下角的意义涉及到齐次坐标的来源，可以自行百度，这里给一个介绍的还不错的博客：什么是齐次坐标? - 知乎 (zhihu.com)。 从真实世界到相机照片可以看作一个射影变换，变换后平行关系由于近大远小可能变成相交关系。 总结 各种变换之间的性质比较如下所示 变换名称 矩阵形式 自由度 不变性质 欧式变换 \\(\\begin{aligned}\\begin{bmatrix}\\pmb{R}&amp;\\pmb{t}\\\\\\pmb{0}^T&amp;1\\end{bmatrix}\\end{aligned}\\) 6 长度、夹角、体积 相似变换 \\(\\begin{aligned}\\begin{bmatrix}s\\pmb{R}&amp;\\pmb{t}\\\\\\pmb{0}^T&amp;1\\end{bmatrix}\\end{aligned}\\) 7 体积比 仿射变换 \\(\\begin{aligned}\\begin{bmatrix}\\pmb{A}&amp;\\pmb{t}\\\\\\pmb{0}^T&amp;1\\end{bmatrix}\\end{aligned}\\) 12 平行性、体积比 射影变换 \\(\\begin{aligned}\\begin{bmatrix}\\pmb{A}&amp;\\pmb{t}\\\\\\pmb{a}^T&amp;v\\end{bmatrix}\\end{aligned}\\) 15 接触平面的相交和相切 相关证明 公式(1)证明 考虑对\\(\\pmb{p}\\)点进行旋转，可得: \\[ \\begin{align*} \\pmb{p}&#39;&amp;=\\pmb{q}\\pmb{p}\\pmb{q}^{-1}=\\pmb{q}^+\\pmb{p}^+\\pmb{q}^{-1}\\\\ &amp;=\\pmb{q}^+\\left(\\pmb{q}^{-1}\\right)^{\\bigoplus}\\pmb{p} \\end{align*} \\] 将矩阵形式带入后得到（这里用到了单位四元数逆等于共轭的性质）： \\[ \\pmb{q}^+\\left(\\pmb{q}^{-1}\\right)^{\\bigoplus}=\\begin{aligned}\\begin{bmatrix}s&amp;-\\pmb{v}^T\\\\\\pmb{v}&amp;s\\pmb{I}+\\pmb{v}^{\\wedge}\\end{bmatrix}\\end{aligned}\\begin{aligned}\\begin{bmatrix}s&amp;\\pmb{v}^T\\\\-\\pmb{v}&amp;s\\pmb{I}+\\pmb{v}^{\\wedge}\\end{bmatrix}\\end{aligned}=\\begin{aligned}\\begin{bmatrix}1&amp;\\pmb{0}\\\\\\pmb{0}^T&amp;\\pmb{v}\\pmb{v}^T+s^2\\pmb{I}+2s\\pmb{v}^{\\wedge}+\\left(\\pmb{v}^{\\wedge}\\right)^2\\end{bmatrix}\\end{aligned} \\] 再根据矩阵的分块乘法，很容得到右下角矩阵乘以\\(\\pmb{p}\\)等于旋转后的结果，即右下角矩阵为旋转矩阵 公式(2)证明 根据旋转矩阵到旋转向量的转换方式，我们先计算旋转矩阵的迹： \\[ \\begin{align*} tr(\\pmb{R})&amp;=tr(\\pmb{v}\\pmb{v}^T)+3s^2+2s\\cdot0+tr(\\left(\\pmb{v}^{\\wedge}\\right)^2)\\\\ &amp;=v_1^2+v_2^2+v_3^2+3s^2-2\\left(v_1^2+v_2^2+v_3^2\\right)\\\\ &amp;=\\left(1-s^2\\right)+3s^2-2\\left(1-s^2\\right)\\\\ &amp;=4s^2-1 \\end{align*} \\] 然后，我们就可以得到\\(\\theta\\)的计算公式 \\[ \\begin{align*} \\theta&amp;=\\arccos(\\frac{tr(\\pmb{R})-1}{2})\\\\ &amp;=\\arccos(2s^2-1) \\end{align*} \\] 即： \\[ \\cos\\theta=2s^2-1 \\] 又因为： \\[ \\cos\\theta=2\\cos^2\\frac{\\theta}{2}-1 \\] 对比可得： \\[ \\theta=2\\arccos(s) \\] 最后就是计算旋转轴，将\\(\\pmb{q}\\)的虚部带入\\(\\pmb{p}\\)的虚部，可以发现： \\[ \\pmb{p}=\\pmb{q}\\pmb{p}\\pmb{q} \\] 即\\(\\pmb{q}\\)的虚部\\([q_1,q_2,q_3]^T\\)旋转后不变，即为旋转轴，将归一化即可得到旋转轴，其模长为 \\[ \\sqrt{q_1^2+q_2^2+q_3^2}=\\sqrt{1-s^2}=\\sqrt{1-\\cos^2\\frac{\\theta}{2}}=\\sin\\frac{\\theta}{2} \\] 参考文档 左手坐标系和右手坐标系 - 知乎 (zhihu.com) 世界坐标系，相机坐标系，图像坐标系，像素坐标系 - 知乎 (zhihu.com) 什么是齐次坐标? - 知乎 (zhihu.com)","categories":[{"name":"机器人","slug":"机器人","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"tags":[]},{"title":"neovim配置和使用","slug":"neovim配置和使用","date":"2022-09-02T02:36:48.000Z","updated":"2023-07-29T05:09:19.000Z","comments":true,"path":"2022/09/02/neovim配置和使用/","link":"","permalink":"https://thomaszb.cn/2022/09/02/neovim%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"使用ipad进行远程开发的时候只能使用vim，我主要使用neovim加插件的方式方便开发，不过neovim也是vim，下面很多快捷键两者是通用的","text":"使用ipad进行远程开发的时候只能使用vim，我主要使用neovim加插件的方式方便开发，不过neovim也是vim，下面很多快捷键两者是通用的 neovim安装和基本使用 在debian家族的linux下，neovim的安装可以直接使用apt包管理工具安装，但一般源里只有较低版本，要使用neovim最新版本需要使用neovim官方源 123sudo add-apt-repository ppa:neovim-ppa/stablesudo apt-get updatesudo apt-get install neovim 经过验证，该方法在ubuntu18.04里面只能下载到0.6的neovim，想要最新版neovim可以选择github下载二进制文件或者自己编译。具体的教程github的wiki上写的较为详细：https://github.com/neovim/neovim 使用 目前体验下来，neovim和vim基本一致，差别主要在于插件。vim的教程可以大概看一下man手册，vim在操作时主要分为以下四种模式： 模式 简介 正常模式（nomal） 打开文件时的默认模式，任何模式下按esc进入，按键不能输入，主要映射为一些功能，比如hjkl为移动等 命令模式（command） 在正常模式下，输入冒号:或/进入，进入后可以使用w写入q退出等操作 插入模式（insert） 在正常模式下，输入i进入，在插入模式下，可以编辑文本 可视模式（visual） 在正常模式下，输入v进入，进入后hjkl可以选中多行，主要用于多行操作 下面，对不同模式的快捷键操作做详细介绍 正常模式 移动光标： 功能 按键 移动单行/列，左/下/上/右 h/j/k/l（或者方向键） 移动到下/上一个单词的末尾/开头 e/b 跳到下/上一个单词开头/结尾 w/ge 向上移动半页（up） ctrl+u 向下移动半页（down） ctrl+d 移动到行首 0或者home 跳转到第一个非空字符 ^ 移动到行尾 $或者end 移动到开头 gg 移动到末尾 G 移动到某一行 n+gg，比如跳到第6行，6gg 移动到下次光标 ctrl+i 移动到上次光标 ctrl+o 跳到下/上一个字符处（forward） f/F 跳到下/上一个字符前（to） t/T 重复上次字符操作（查找之类的） ; 反向查找上次的查找命令 , 删除： 功能 按键 删除光标后/前的一个字符 x/X 剪切光标所在行 dd 复制：yy，复制一行 粘贴：p/P，在光标后/前粘贴 撤回：u 其他技巧： 数字加上述命令可以多次执行。如5j，向下5行，3x，删除3个。 搜索：输入后按回车进入普通模式，再通过n/N可以向下/上跳转匹配对象 功能 按键 搜索 / 向上搜索 ? 搜索当前光标所在单词 * 向上搜索当前光标所在单词 # 在该模式下按ctrl+v可以进入多行编辑模式，选择要编辑的多行，按大写的I编辑，编辑完后esc退出即可插入到每一行。同时在该模式下，可以使用&gt;、&lt;来实现多行tab的功能。 命令模式 命令行模式除了输入下述命令外，还可以输入所安装插件支持的命令。 文件保存和退出 退出：q 保存：w 保存并退出：wq 显示行号：set nu开启，set nonu关闭 替换： :n1,n2/word1/word2/g：将n1到n2行之间的word1替换为word2，不加g则只替换每行的第一个word1，加g则搜到的word1全部替换为word2 :1,$s/word1/word2/g：将文章中的word1替换为word2，不加g则只替换每行的第一个word1 其他 强制执行命令：加上! 多文件操作 在当前打开文件的基础上再打开一个文件：e xxx 查看当前打开的文件：ls 切换到上一个：bp 切换到下一个：bn 切换到某一个：bx（x为数字） 分屏操作 水平分割：sp（后面可以跟文件） 垂直分割：vsplit 切换窗口：ctrl+w+h/j/k/l 依次切换：ctrl+ww 插入模式 插入模式根据需求，可以用不同种方式进入 进入方式 效果 i 在光标所在字符前开始输入文字并进入插入模式 I 在行首开始输入文字并进入插入模式。此行首指第一个非空白字符处。 a 在光标所在字符后开始输入文字并进入插入模式 A 在行尾开始输入文字并进入插入模式 o 在光标所在行的下面单独开一新行，来输入文字并进入插入模式 O 在光标所在行的上面单独开一新行来输入文字并进入插入模式 s 删除光标所在的字符并进入插入模式 S 删除光标所在行并进入插入模式 可视模式 正常模式下v进入字符文本，V进入行文本，进入后可以选中文本，选中后常用的快捷键如下 功能 快捷键 删除 d 复制 y 粘贴 p 替换 r 大小写转换 gu转换为小写，gU转换为大写，g~大小写互换 常用快捷键基本就是以上这些，当然快捷键还可以自己设置，结合neovim安装的插件可以让开发效率更快。 基本配置 neovim配置可以通过lua文件配置，默认使用的配置文件地址为$&#123;HOME&#125;/.config/nvim/init.lua，常用的配置如下 123456789vim.o.number = truevim.o.tabstop = 2vim.o.shiftwidth = 2vim.o.expandtab = truevim.o.smartindent = truevim.o.termguicolors = truevim.o.cursorline = truevim.g.mapleader = &#x27; &#x27; 当然，打开nvim后再命令模式也可以修改上述配置（vim可以，nvim有待验证），比如我常修改tabsize: set ts=4 neovim插件安装 neovim可以使用lua文件来进行插件的配置，插件一般在github上可以搜索到。neovim可以使用packer插件来进行插件的管理（一个管理插件的插件&gt;_&gt;） neovim常用的插件可以在rockerBOO/awesome-neovim: Collections of awesome neovim plugins. (github.com)网站中查找 安装packer packer插件的github官网为： wbthomason/packer.nvim: A use-package inspired plugin manager for Neovim. Uses native packages, supports Luarocks dependencies, written in Lua, allows for expressive config (github.com) 安装时跟着官网的教程走即可 其他常用插件推荐 主题：tokyonight 代码提示：nvim-lspconfig 侧边栏：nvim-tree.lua 打开的文件栏：telescope 文件搜索：telescope 这里就不介绍具体的安装方式什么的了，后面我会将我的配置放在github上。 安装好插件后，插件的使用一般参考官方的文档即可。也是比较麻烦，这里我记录下我常用的插件的几个快捷键。 goto-preview 使用该 删除插件 注释插件安装处的lua配置use-end块 PackerClean删除 neovim快捷键设置 设置快捷键使用的命令较长vim.api.nvim_set_keymap，这里可以使用local命令重命名一下，下面直接给出快捷键设置的示例： 123456789101112131415local map = vim.api.nvim_set_keymap local opt = &#123;noremap = true, silent = true&#125;-- set up down to 9 line map(&quot;n&quot;, &quot;&lt;S-j&gt;&quot;, &quot;9j&quot;, opt) map(&quot;n&quot;, &quot;&lt;S-k&gt;&quot;, &quot;9k&quot;, opt) -- file explore map(&quot;n&quot;, &quot;&lt;C-b&gt;&quot;, &quot;:NvimTreeToggle&lt;CR&gt;&quot;, opt) -- buffer line toggle map(&quot;n&quot;, &quot;&lt;S-h&gt;&quot;, &#x27;:BufferLineCyclePrev&lt;CR&gt;&#x27;, opt) map(&quot;n&quot;, &quot;&lt;S-l&gt;&quot;, &#x27;:BufferLineCycleNext&lt;CR&gt;&#x27;, opt) map(&quot;n&quot;, &quot;&lt;C-f&gt;&quot;, &#x27;:Telescope find_files&lt;CR&gt;&#x27;, opt) 其中，opt为选项，我也不知道啥意思。 参考文档 (14条消息) Vim的4种模式_还能坚持的博客-CSDN博客_vim模式 Neovim 的快捷键配置 - 知乎 (zhihu.com) vim的搜索与替换 - 知乎 (zhihu.com)","categories":[{"name":"程序猿基础技能","slug":"程序猿基础技能","permalink":"https://thomaszb.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"基于图优化的SLAM","slug":"基于图优化的SLAM","date":"2022-06-30T05:50:54.000Z","updated":"2023-07-13T16:07:28.329Z","comments":true,"path":"2022/06/30/基于图优化的SLAM/","link":"","permalink":"https://thomaszb.cn/2022/06/30/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9A%84SLAM/","excerpt":"SLAM：同时定位和建图","text":"SLAM：同时定位和建图 SLAM简介 SLAM即同时定位和建图（simultaneous localization and mapping），目前主流有2种方法，一种是基于滤波器的SLAM，一种是基于图优化的SLAM。基于滤波器的SLAM由于误差会累计，目前更流行的方法为基于图优化的SLAM，本文也主要讲解基于图优化的SLAM。 环境理想下的机器人定位 SLAM中定位常用scan-match，建图目前我只了解了栅格地图的构建方法，栅格地图的构建主要分为覆盖栅格建图和计数建图。 几种scan-match scan-match是匹配scan数据的一种方式，scan数据这里指的是range data，在2d激光雷达定位中指的通常是激光数据。激光数据通常可以用结构体表示，通常可以用以下数据结构表示 12345struct RangeData&#123; Eigen::Vector3f origin; PointCloud returns; PointCloud misses;&#125;; 其中origin为激光数据的中心位姿，returns为激光扫描到的数据，里面有激光相对于origin的vector数据。misses为激光发射出去，未返回的数据。也就是没射到障碍物。 scan-match分为以下几类： scan-to-scan：激光数据和激光数据做对比，可以得到两帧激光数据的相对位姿 scan-to-map：可以得到激光数据在map中的相对位姿 map-to-map：可以得到两个地图的相对位姿 SLAM建图的基本原理-覆盖栅格建图 获得预测位姿 获得预测位姿通常有多种方法，通常是通过里程计和IMU获得位姿的预测。也可以通过scan-match来。 将激光数据插入地图中 根据预测的位姿，将激光点加入到 SLAM中的简单问题 SLAM中的误差累计问题 基于图优化的SLAM 基于图优化的SLAM整体框架如图所示，输入传感器采集的数据，通常包括雷达、IMU、里程计等，IMU和里程计数据输入到PoseExtrapolator中可以得到位姿的预测值。激光经过体素滤波器后送到Local SLAM中，经过匹配后得到机器人的位姿输出，同时把激光数据加入到子图中。 Local SLAM会把激光以及完成的子图发送到Global SLAM中，Global SLAM会把激光拿去做回环检测，判断机器人是否从新回到了某个位姿，回环检测成功后，Optimization模块会根据回环检测的结果优化消除累计误差。 前端构图 这里的前端构图指的是数据结构中的图，而不是地图，这点一定要分清楚！ 记一个东西，\\(z_{ij}\\)其实是j变换到i的变换矩阵（好像是吧，这里还不太确定），这个还是没太搞懂，最好看一下 后端优化 找到最满足约束条件的机器人位姿配置，本文讲解的方法为非线性最小二乘法，使用高斯-牛顿法迭代求解。 ​ 图中的误差为两点之间的差，则误差为，至于怎么推导出来的，待会儿讲解： \\[ e_{ij}=t2v(Z_{ij}^{-1}(x_i^{-1} \\cdot x_j)) \\] 则有： \\[ e_{ij}= \\begin{bmatrix} R_{z}^T(R_i^T(t_j-t_i)-t_{z}) \\\\ \\theta_j-\\theta_i-\\theta_{z} \\end{bmatrix} \\] 式中，\\(R\\)为旋转矩阵，表示两个坐标系旋转前后的坐标变换关系，跟旋转角\\(\\theta\\)的转换关系如下所示： \\[ R= \\begin{aligned} \\begin{bmatrix} cos\\theta &amp; -sin\\theta \\\\ sin\\theta &amp; cos\\theta \\end{bmatrix} \\end{aligned} \\] 优化步骤 计算误差： \\[ e_{ij}=t2v\\left(Z_{ij}^{-1}(x_i^{-1} \\cdot x_j)\\right) \\] 则有： \\[ e_{ij}= \\begin{bmatrix} R_{z}^T(R_i^T(t_j-t_i)-t_{z}) \\\\ \\theta_j-\\theta_i-\\theta_{z} \\end{bmatrix} \\] 求出雅可比矩阵\\(J_{ij}\\)： \\[ J_{ij}=\\left(\\cdots\\frac{\\partial e_{ij}(x+\\Delta x)}{\\partial\\Delta x_i}\\cdots\\frac{\\partial e_{ij}(x+\\Delta x)}{\\partial\\Delta x_j}\\cdots\\right) \\] 求出\\(H_{ij}\\)矩阵： \\[ H_{ij}=J_{ij}^T\\Omega_{ij}J_{ij} \\] 求出\\(b_{ij}\\)向量： \\[ b_{ij}^T=e_{ij}^T\\Omega_{ij}J_{ij} \\] \\[ b_{ij}=\\left(\\left(b_{ij}^T\\right)^T\\right) \\] 更新\\(H\\)矩阵和\\(b\\)向量第\\((i,j)\\)项： \\[ H=H+H_{ij} \\] \\[ b=b+b_{ij} \\] 计算完所有的约束项后，根据下式计算\\(\\Delta x\\)（一般不通过求逆，而是稀疏矩阵的求法，主要式为了减小运算量）： \\[ H\\Delta x=-b \\] 更新\\(x\\)： \\[ x = x+\\Delta x \\] 实际情况的改进（算法具体实现） ​ 实际情况中，由于雅可比行列式J是稀疏的，通常不用矩阵乘法，直接计算出特定位置的值即可，这里根据实际情况改进上述对应的步骤。 求出雅可比矩阵（只用求i项和j项）： 由于\\(\\Delta x\\)有3项，这里对\\(\\Delta x\\)求偏导也是求出其雅可比行列式，求出的结果如下式所示： \\[ A_{ij}=\\frac{\\partial e_{ij}(x+\\Delta x)}{\\partial\\Delta x_i}= \\begin{bmatrix} -R_z^TR_i^T &amp; R_z^T\\frac{\\partial R_i^T}{\\partial \\theta_i}(t_j-t_i) \\\\ 0 &amp; -1 \\end{bmatrix} \\] \\[ B_{ij}=\\frac{\\partial e_{ij}(x+\\Delta x)}{\\partial\\Delta x_j}= \\begin{bmatrix} R_z^TR_i^T &amp; 0 \\\\ 0 &amp; 1 \\end{bmatrix} \\] 更新\\(H\\)（直接求出\\(H\\)矩阵中对应的元素加上去）： \\[ H[ii] +=A_{ij}^T\\Omega_{ij}A_{ij} \\] \\[ H[ij] +=A_{ij}^T\\Omega_{ij}B_{ij} \\] \\[ H[ji] +=B_{ij}^T\\Omega_{ij}A_{ij} \\] \\[ H[jj] +=B_{ij}^T\\Omega_{ij}B_{ij} \\] 更新\\(b\\)（直接求出\\(b\\)对应位置的元素加上去）： \\[ b[i]+=A_{ij}^T\\Omega_{ij}e_{ij} \\] \\[ b[j]+=B_{ij}^T\\Omega_{ij}e_{ij} \\] 上述步骤循环到\\(C\\)（所有约束的集合）计算完 参考文献","categories":[{"name":"机器人","slug":"机器人","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"tags":[]},{"title":"专利申请-权利要求书","slug":"专利申请-权利要求书","date":"2021-03-19T04:56:41.000Z","updated":"2023-07-13T16:06:45.419Z","comments":true,"path":"2021/03/19/专利申请-权利要求书/","link":"","permalink":"https://thomaszb.cn/2021/03/19/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7-%E6%9D%83%E5%88%A9%E8%A6%81%E6%B1%82%E4%B9%A6/","excerpt":"权利要求书是专利申请过程中最重要的一部分，他关系到专利能不能授权，以后有人侵权时能不能告侵权人，一般说明书和权利要求书是相互作用的","text":"权利要求书是专利申请过程中最重要的一部分，他关系到专利能不能授权，以后有人侵权时能不能告侵权人，一般说明书和权利要求书是相互作用的 权利要求书简介 作为专利申请最重要的两个文件（专利说明书和权利要求书）之一的权利要求书，一般关系到自己的专利能不能授权，审查机构授权时主要也是看你的权利要求书与现有技术有无冲突或者区别大不大。在告发对方侵权时，法院也是看权利要求书判断是否构成侵权。 所以一个好的专利，权利要求书非常重要，而如果想要混几个专利，权利要求书当然也很重要（关系到专利能不能授权）。 权利要求书特点 侵权与授权（重要） 一般来说，专利想要越容易授权，那么它就越不容易构成侵权，举个例子：如果专利为一个鼠标，那么肯定申请不下来，因为鼠标大家都有，而且相关专利已经很多了，但是如果申请下来，所有做鼠标的厂商都构成侵权；而如果专利为一个鼠标，颜色为红色，鼠标做边有个小猫，右边有个小狗，按键是一个小猪，那么这个专利很容易申请下来，但是想要告别人侵权，只要对方的鼠标有一个条件没有满足自己专利的特征，那么他就不构成侵权，比如对方做一个产品，左边是一个小猫，右边是一个小狗，按键是一个小熊，那么没有构成侵权。 权利要求书的构成 权利要求的分类 产品权利要求 作用于：制造、使用、许诺销售、销售、进口其专利产品 方法权利要求 作用于：使用其专利方法以及使用、许诺销售、销售、进口依照该专利方法直接获得的产品 一般为了更好的保护专利，写专利时，两种权利要求都要写上，比如： 12一种麦克风录音方法，其特征在于，录音，信号处理，信号传输一种麦克风录音装置，其特征在于，录音模块用于录音，信号处理模块用于语音信号处理，信号传输模块用于传输信号 特征的意思是该专利独有的，如果对方的产品满足特征所有要求，则构成侵权。当然如果特征越少，越难授权，如上述的侵权于授权介绍。 权利的分类 独立权利要求 一个专利可以写多个独权，独权越多越好，如果要告别人侵权，那么就可以选一个独权来告。独权可以包含不同的行为，用于针对侵权人可能的不同方式的侵权。比如为了铺平床单在两边加上袋子用于装重物： 1234一种铺平床单的方法，其特征在于，包括：在床单的矩形对边分别安装两条条状物；对铺在床上的床单的两条条形物同时相向施力。一种床单，其特征在于，包括：设置在床单的矩形边条状袋子，其中，所述袋子用于设置条状物。一种床单，其特征在于，包括：设置在床单的矩形对边条状袋子，其中，所述条状袋子的宽为2cm至5cm。一种床单..... 从属权利要求 偏技术，层层递进。用附加的技术特征对引用的权利要求（包括独立或从属权利要求）进一步限定的权利要求。从属权利要求是独立权利要求的下位权利要求，是对独立权利要求改进，本身必定落入独立权利保护范围之内，但通过增加新的技术特征进一步优化和限定独立权利要求。侵犯从属权利要求就必然侵犯独立权利要求，而侵犯独立权利要求未必直接侵犯从属权利要求。然而从属权利也有自身不可替代的重要功能，其中最突出的就是在独立权利要求万一被宣告无效时可以被提升为新的独立权利要求，把从属权利修改为新的独立权利要求从而维持专利申请案得以通过。 开始写权利要求书 找到所有的技术特征 从中提取关键技术特征 进行上位描述形成独立权利要求 剩下的特征进行从属权利要求布局 描述过程很重要，有些东西知道怎么用，知道长什么样，但是很难描述，一般多看看别人怎么写。这个步骤主要还是靠多练，要把想法通过技术描述出来，比如保存日记，用技术描述出来就是保存文本。","categories":[{"name":"专利","slug":"专利","permalink":"https://thomaszb.cn/categories/%E4%B8%93%E5%88%A9/"}],"tags":[]},{"title":"Cmake使用","slug":"Cmake使用","date":"2021-03-14T11:36:33.000Z","updated":"2023-08-07T02:54:29.000Z","comments":true,"path":"2021/03/14/Cmake使用/","link":"","permalink":"https://thomaszb.cn/2021/03/14/Cmake%E4%BD%BF%E7%94%A8/","excerpt":"众所周知，Makefile可以方便的进行项目的编译等等，可是对于很大的项目（不同文件放在不同地方），要写一个makefile出来可不容易，所以就有了Cmake，它可以用来方便的构建c/c++的makefile，更方便项目的管理","text":"众所周知，Makefile可以方便的进行项目的编译等等，可是对于很大的项目（不同文件放在不同地方），要写一个makefile出来可不容易，所以就有了Cmake，它可以用来方便的构建c/c++的makefile，更方便项目的管理 Cmake简介 功能 CMake是一个开源的工具，通过编写几行简单的CMakeLists.txt，就可以快速生成Makefile。同时，cmake还支持编译生成库、安装程序到指定目录等操作。 安装 linux安装 一般系统自带，可以通过cmake --version查看cmake版本，如果发现没有cmake，则通过包管理工具安装即可，如： sudo apt-get install cmake windows安装 如果用的cgwin安装的mingw的话，直接从新点开cgwin的安装程序勾选上cmake，安装即可： 也可以官网下载： 官网下载最新的cmake：CMake 安装时最好选择添加到环境变量（也可以后面自己添加），如果电脑是自己的，选择添加到所用用户即可 在命令行检测是否安装成功：cmake --version 基本语法和常用指令 CmakeLists.txt的编写方法通过一个一个的指令构成，通常先指定项目名称、Cmake版本号；再通过添加源文件到一个变量，添加头文件目录、添加链接库、生成可执行文件等步骤，就完成了对一个简单工程的构建。 简单的CmakeLists构成只需要项目名和源文件名、可执行文件名即可 12PROJECT(main)ADD_EXECUTABLE(hello main.c) 基本语法 基本原则 变量使用${}取值，IF控制语句中直接使用变量名 关键字(参数一 参数二 …)，参数用圆括号括起来，参数之间使用空格或分号分开 关键字大小写无关，参数和变量区分大小写，推荐大写关键字 注意事项 SET(SRC_LIST main.cpp)可以写成SET(SRC_LIST “main.cpp”) ，如果有空格则必须加双引号 ADD_EXECUTABLE(hello main)，main.cpp的后缀可以不写 常用指令 PROJECT 功能：指定工程名字和支持的语言（默认支持所有语言）。同时，该指令隐式定义了两个变量： _BINARY_DIR，本例中是：HELLO_BINARY_DIR（等于PROJECT_BINARY_DIR），指向当前工作目录。 _SOURCE_DIR，本例中是：HELLO_SOURCE_DIR（等于PROJECT_SOURCE_DIR），指向当前工作目录。 参数： 工程名 语言 12project (HELLO) # 支持所有语言project (HELLO C CXX) # 支持c和c++ SET 功能：显式的指定变量，一般用于将多个源文件用一个变量表示，也可以用于设置某些变量（如目录）的值 参数： 变量名 添加的文件 12set(SRC_LIST main.cpp hello.cpp) # SRC_LIST包含了main.cpp和hello.cppset(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) # 设置bin文件生成路径 ADD_EXECUTABLE 功能：生成可执行文件 参数： 可执行文件名 源文件，通常结合上一个SET命令创建的文件列表 1add_executable(hello $&#123;SRC_LIST&#125;) # 前面为可执行文件的名字，后面为源文件 ADD_SUBDIRECTORY 功能：向当前工程添加存放文件的子目录（一般用在最外层CMakeLists.txt上） 说明：cmake可以在每个目录下面都写CMakeLists.txt，写上这个目录中要干的事情，一般是编译哪些文件之类的。然后最外层的CMakeLists.txt通过指令将其他层目录加入进来，里面的CMakeLists.txt也会执行。 参数： source_dir：源文件目录 bin_dir：可选，生成的二进制文件目录 EXCLUDE_FROM_ALL：可选，将source_dir目录从源文件中删除 1add_subdirectory(src bin) INCLUDE_DIRECTORIES 功能：添加头文件 参数： 头文件目录，可以多个 123456789include_directories(Core/Inc Drivers/STM32F1xx_HAL_Driver/Inc Drivers/STM32F1xx_HAL_Driver/Inc/Legacy Drivers/CMSIS/Device/ST/STM32F1xx/Include Drivers/CMSIS/Include Drivers/GUI Drivers/GUI/lvgl Drivers/GUI/lv_examples Drivers/GUI/lvgl_driver Drivers/GUI_APP) LINK_DIRECTORIES 功能：添加链接库的目录，相当于gcc的-L选项 参数： 库目录，可以多个 1link_directories(&quot;/opt/MATLAB/R2012a/bin/glnxa64&quot;) TARGET_LINK_LIBRARIES 功能：链接库，加在ADD_SUBDIRECTORY后面。 参数： 可执行文件，链接生成库的位置 库名，可以有多个 123target_link_libraries(vipc vips)target_link_libraries(vipc glib-2.0)target_link_libraries(vipc gobject-2.0) FILE 功能：文件操作，可以用来读文件之类的。我主要用来递归添加所有源文件 参数： 操作：可以选择递归获得源文件，即GLOB_RECURSE 变量名 目录 1234# 导入源文件file(GLOB_RECURSE SOURCE_DRIVERS $&#123;PROJECT_SOURCE_DIR&#125;/src/lv_sim_vscode_sdl/GUI/lv_drivers/*.c)file(GLOB_RECURSE SOURCE_EXAMPLES $&#123;PROJECT_SOURCE_DIR&#125;/src/lv_sim_vscode_sdl/GUI/lv_examples/src/*.c)file(GLOB_RECURSE SOURCE_LVGL $&#123;PROJECT_SOURCE_DIR&#125;/src/lv_sim_vscode_sdl/GUI/lvgl/src/*.c) 其他操作：CMake file文件操作命令_Huo的藏经阁的博客-CSDN博客_cmake file MESSAGE 功能：打印消息 参数： ADD_DEFINITIONS 功能：添加宏定义 参数： 宏定义 1234add_definitions(-DXXX) # 这个是定义XXXadd_compile_definitions(NONE_VALUE_MACRO) # 这个cmake3.12后才支持add_definitions(-DNONE_VALUE_MACRO=0x10000000) # 有参宏add_compile_definitions(VALUE_MACRO=0x10000000) # 这个cmake3.12后才支持 其他指令 https://www.cnblogs.com/lidabo/p/7359217.html 环境变量 cmake有个可以设置独立的环境变量CMAKE_INCLUDE_PATH，在Linux下可以用export CMAKE_INCLUDE_PATH=xxx，来让这个库加入cmake的环境变量。 跟project有关的环境变量 &#123;PROJECT_NAME&#125;_BINARY_DIR： &#123;PROJECT_NAME&#125;_SOURCE_DIR： bin文件生成目录的环境变量 EXECUTABLE_OUTPUT_PATH：可以通过set命令修改 安装相关的环境变量 CMAKE_INSTALL_PREFIX：安装路径，可以通过set命令指定，也可以在cmake时用-D CMAKE_INSTALL_PREFIX=xxx指定，默认是在usr/local 跟系统环境变量有关： CMAKE_INCLUDE_PATH：可以将自己的头文件写在里面 CMAKE_LIBRARY_PATH：可以将自己的库写在里面 使用 cmake时指定宏定义参数 12cmake -DNONE_VALUE_MACRO ..cmake -DVALUE_MACRO=0x10000000 .. 构建和结构 一般使用cmake [CMakeLists.txt目录]就可以完成构建，构建的文件在执行这个命令的目录下 内部构建和外部构建 内部构建就是在本目录下直接构建，比如cmake .，这样构出来很多临时文件和自己的文件混在一起，如下图所示，不方便项目的构建和管理。 而外部构建一般是指将生成的文件放在另一个目录（即不和CMakeLists.txt一个目录），一般创建一个文件夹，再在里面进行编译： 1234mkdir buildcd buildcmake ..make 这样生成的文件就会在build下面，使整个工程看起来更整洁。 基本结构 cmake管理的工程目录按照不同习惯有很多种，根据实际开发或需要做调整，常见的结构如下： src：源码目录 doc：说明文档，可以通过cmake安装到/usr/share/doc/cmake/目录下 COPYRIGHT,README：版权和说明，同样可以安装到上述目录下 build：构建生成的文件目录，里面一般包含bin目录，可执行文件一般生成在这个bin目录 构建好的基本结构如下所示： 这里使用了多级目录下的CMakeLists.txt，最外层的CMakeLists.txt如下所示： 1234# 定义工程名project(main)# 关联子目录，并设置生成的东西放入bin目录add_subdirectory(src bin) src目录下的CMakeLists.txt如下所示： 123# 子目录中的CMakeLists.txt只用管该目录下需要生成的文件（也可以设置工程名）set(SRC_LIST helloworld.cc)add_executable(hello $&#123;SRC_LIST&#125;) 使用CMake来安装 安装一般是指将编译好的文件安装（或者说是移动）到某个目录，一般有两种方法指定目录： 简单的指定目录（安装时指定）：make install DESTDIR=/tmp/test 高级的指定目录（生成makefile时指定）：./configure -prefix=/usr，后面安装时make install INSTALL命令简介 安装需要用到INSTALL指令，该指令具体介绍在上面，接下来简单介绍一下该指令 功能：用于安装，INSTALL的安装可以包括二进制、动态库、静态库以及文件、目录、脚本等 参数： 类型： FILES：安装文件，后面根安装的文件名 PROGRAMS：非目标文件的可执行程序安装（比如脚本文件） DIRECTORY：安装目录，后面根目录名abc表示abc被安装到目标目录，abc/表示abc里面的问题被安装到目标目录 TARGETS：安装目标文件，一般要和生成这个目标文件的CMakeLists.txt在同一级目录下，否则会找不到目标文件 DESTINATION：安装位置，一般需要写绝对路径，也可以写相对路径，会自动在前面加上默认路径的环境变量，比如$&#123;CMAKE_INSTALL_PREFIX&#125;/abc 安装具体操作 在安装前，通常的目录结构如下所示： 然后一般在最外层的CMakeLists.txt添加安装命令 1234567891011# 定义工程名project(main)# 关联子目录，并设置生成的东西放入bin目录add_subdirectory(src bin)# 安装文件# 将copyright和readme安装在/usr/local/share/doc/cmake下面install(FILES COPYRIGHT README DESTINATION share/doc/cmake)# 安装脚本（实际位置为/usr/locar/bin）install(PROGRAMS runhello.sh DESTINATION bin)# 安装目录install(DIRECTORY doc/ DESTINATION share/doc/cmake) 然后执行编译，安装： 123cmake ..makesudo make install 构建共享库 首先，什么是库？库就是别人可以直接调用的，编译好的文件，只需要使用库提供的.h文件就可以使用库里面的函数，需要注意的是，使用库必须链接到库，否则会出现xxx未定义等错误。 静态库和动态库的区别： 静态库拓展名一般为.a或.lib；动态库拓展名一般为.so或.dll 静态库会直接整合到目标程序中，编译成功的可执行文件可以独立运行 动态库编译时不会放到链接的目标程序中，即可执行文件无法单独运行 ADD_LIBRARY命令简介 功能：创建共享库 参数： 库名：库的名称name，生成的库会自动加上lib，所以最后的名字为libname.so 库类型： SHARED：动态库 STATIC：静态库 源文件 下面以创建HelloFunc的库函数为例，建立动态库和静态库，并实现调用。 创建操作 首先，正常创建好平时使用的.h和.cc文件，并完成代码的编写，整体目录结构如下： 完成外层CMakeLists.txt的编写，外层编写和前面的基本结构的外层一致，无需其他额外的操作，然后是完成内部的CMakeLists.txt的编写，具体如下所示： 123set(LIBHELLO_SRC hello.cc)# 创建库add_library(hello SHARED $&#123;LIBHELLO_SRC&#125;) 如果要同时构建动态库和静态库，一种方法是给动态库和静态库取不同的名称，还有一种方法是使用SET_TARGE_PROPERTIES指令来重名名名称，该指令还可以指定动态库版本和API，具体如下所示： 1234567891011121314set(LIBHELLO_SRC hello.cc)# 创建静态库add_library(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)# 重命名set_target_properties(hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;)# 清除hello这个命名（实际生成的文件没有删除），后面才可以使用helloset_target_properties(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)# 创建动态库add_library(hello SHARED $&#123;LIBHELLO_SRC&#125;)# 重命名set_target_properties(hello PROPERTIES OUTPUT_NAME &quot;hello&quot;)set_target_properties(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) 生成的文件如下所示： 接下来是安装共享库，第一步要安装头文件，第二部要安装库，具体要在内层（不然找不到目标文件）CMakeLists.txt里面加上如下两句： 123install(FILES hello.h DESTINATION include/hello)# 分别安装动态库和静态库到lib目录下install(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) 然后安装目录修改为usr/这样才能保证能够直接调用： 123cmake -D CMAKE_INSTALL_PREFIX=/usr ..makesudo make install 使用步骤 使用时，根据安装的位置不同，需要的工作也不同，头文件如果安装在/usr/include/下面（这个是在环境变量中的），那么头文件就可以直接使用。同理，如果库安装在/usr/lib下面，库也可以直接链接。 对于未安装在/usr/include下面的头文件，需要使用INCLUDE_DIRECTORIES将头文件目录加入。 对于库的链接有两种方法： LINK_DIRECTORIES：添加非标准共享库搜索路径（库没有安装在usr/lib下面，有些需要在usr/lib64下面） TARGET_LINK_LIBRARIES：添加标准库，直接写库的名称就行（注意要写在add_executable后面） 这里使用前面HelloFunc需要的CMakeLists.txt如下： 123456# 加入头文件搜索路径include_directories(/usr/include/hello)add_executable(hello main.cc)# 链接库target_link_libraries(hello libhello.so) 这里的库可以使用find来找，这里先不做介绍 FIND_PACKAGE find_package常用来寻找库，得到库的一些信息，然后使用。注意：find_package只能寻找用cmake安装的库，本质是查找环境变量中对应库的xxx.cmake，如果库目录中没有该文件，显然是无法通过find_package来找的，不过还好大部分库都是通过cmake安装的。 find_pacakge命令介绍 功能：查找库 参数： REQUEST：可选，如果选择，找不到包时就终止cmake命令 库：可以有多个 如果找到了想要的库，一般会得到以下几个环境变量： &lt;LibaryName&gt;_FOUND：返回值，是否找到，可以用在if语句进行某些操作 &lt;LibaryName&gt;_INCLUDE_DIR：头文件目录 &lt;LibaryName&gt;_INCLUDES：头文件 &lt;LibaryName&gt;_LIBRARY：库目录 &lt;LibaryName&gt;_LIBRARIES：库 使用步骤 首先通过find_package找需要的包 1find_package(CURL) 然后添加头文件和链接库 12target_include_directories(clib PRIVATE $&#123;CURL_INCLUDE_DIR&#125;)target_link_libraries(curltest $&#123;CURL_LIBRARY&#125;) 注意事项 windows下如果用的mingw的话，编译要加上-G\"MinGW Makefiles\"（不然会调用vs的nmake），则编译指令（如果编译过的话就需要删除之前的编译文件重新编译）： cmake -G”MinGW Makefiles” .. 可调试版本生成（可用gdb调试）： cmake .. -DCMAKE_BUILD_TYPE=debug 参考链接 https://zhuanlan.zhihu.com/p/97369704","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://thomaszb.cn/categories/C-C/"}],"tags":[]},{"title":"Make和Makefile","slug":"Make和Makefile","date":"2021-03-14T11:29:35.000Z","updated":"2023-02-27T07:38:53.386Z","comments":true,"path":"2021/03/14/Make和Makefile/","link":"","permalink":"https://thomaszb.cn/2021/03/14/Make%E5%92%8CMakefile/","excerpt":"make和makefile用于方便开发c语言，让编译和管理项目变得简单，最重要的是makefile可以根据时间戳自动判断哪些文件是更改过的，编译时就只用编译需要编译的，大大减少了编译等待的时间（摸鱼的时间）","text":"make和makefile用于方便开发c语言，让编译和管理项目变得简单，最重要的是makefile可以根据时间戳自动判断哪些文件是更改过的，编译时就只用编译需要编译的，大大减少了编译等待的时间（摸鱼的时间） 介绍 Makefile的性质和功能 makefile是一种脚本语言，通过该目录下的make运行该脚本语言 功能：可以自动完成编译工作 如果修改了某几个源文件，则只重新编译这几个源文件 如果某个头文件被修改了，则重新编译所有包含头文件的源文件 基本语法和结构 注释：# 显式规则： 目标文件：依赖文件换行[TAB]命令 说明：上面一行是目标和依赖，下面一行为指令（可以由多行），这里需要注意，如果依赖没有就去执行目标文件为依赖文件的指令，否则就直接执行，所以通常第一个目标为最终目标 例： 1234567891011hello:hello.o gcc hello.o -o hellohello.o:hello.s gcc -C hello.s -o hello.ohello.s:hello.i gcc -S hello.i -o hello.s hello.i:hello.c gcc -E hello.c -o hello.i 注：这里为什么要分步骤写？ ​ 当某个文件改动时，如果没有中间文件，那么编译时就会重新编译所有文件，非常浪费时间，但有中间文件时，编译会编译修改的文件，相当于只用重新链接一下 伪目标：.PHONY:换行参数换行[TAB]命令 说明：make时跟上这些参数就可以执行相应的命令 例： 1234# 使用make clear清除生成的中间文件.PHONY:clear: rm -rf hello.o hello.s hello.i hello 多文件编译 说明：其实跟单文件步骤差不多 例： 123456last:funciton.o main.o gcc function.o main.o -o lastfunction.o:function.c gcc -c function.c -o function.omain.o:main.c gcc -c main.c -o main.o 变量 简单的替换：=（使用$()取值） 说明：直接用该变量后面的所有内容替换相应的定义 例： 1234567891011TAR = testOBJ = circle.o cube.o main.oCC := gcc$(TAR):$(OBJ) $(CC) $(OBJ) -o $(TAR)circle.o:circle.c $(CC) -c circle.c -o circle.o...... 追加：+= 说明：在变量后面再加东西，相当于python的两个字符串相加 例： 12345678910111213TAR = testOBJ = circle.o cube.o main.oCC := gcc# 添加了新的文件OBJ += func.o$(TAR):$(OBJ) $(CC) $(OBJ) -o $(TAR)circle.o:circle.c $(CC) -c circle.c -o circle.o...... 恒等于：:=（即不能追加和修改） 隐含规则 任意名称：% 说明：使用时直接用%代替任意的名称，常用再目标文件和依赖文件，表示任意文件都执行下述命令 例： 123456789TAR = testOBJ = circle.o cube.o main.oCC := gcc$(TAR):$(OBJ) $(CC) $(OBJ) -o $(TAR)%.o:%.c $(CC) -c %.c -o %.o 所有名称：* 说明：用于指定编译该文件夹下的所有文件，如*.c 通配符 符号 含义 $@ 所有目标文件 $^ 所有依赖文件 $&lt; 所有依赖文件的第一个文件 $+ 所有的依赖文件，以空格分开，可能包含重复的依赖文件 $* 不含拓展名的目标文件名称 $? 所有时间戳比目标文件晚的依赖文件，空格分开 补充 c语言编译过程 预处理： 把.h .c展开形成一个文件 宏定义直接替换，库文件直接打开 形成.i文件 对应的gcc指令：gcc -E hello.c hello.i 编译： 生成汇编文件（即.s文件） 对应的gcc指令： gcc -S hello.i -o hello.s 汇编： 将汇编语言转化为机器码 生成二进制文件（编译生成的二进制文件，可由计算机直接执行） 对应的gcc指令： gcc -C hello.i -o hello.s 链接： 生成最终可执行文件（程序） 对应的gcc命令：gcc hello.o -o hello gcc其他指令 添加宏定义：-D 链接库：-l 编译程序位数32位或则64位程序：-m32 优化指令等级：-O 指定c++版本：-std==c99","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://thomaszb.cn/categories/C-C/"}],"tags":[]},{"title":"IntelRealSense树莓派环境搭建","slug":"IntelRealSense树莓派环境搭建","date":"2021-03-08T07:22:31.000Z","updated":"2023-02-27T07:38:53.386Z","comments":true,"path":"2021/03/08/IntelRealSense树莓派环境搭建/","link":"","permalink":"https://thomaszb.cn/2021/03/08/IntelRealSense%E6%A0%91%E8%8E%93%E6%B4%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"最近在做一个项目用到了intelrealsense，以后可能还会用到该设备，这里记录下树莓派搭建环境的步骤","text":"最近在做一个项目用到了intelrealsense，以后可能还会用到该设备，这里记录下树莓派搭建环境的步骤 安装前准备 这里先扔一个连接，后面再写-里面有些东西还没理解（https://github.com/acrobotic/Ai_Demos_RPi/wiki/Raspberry-Pi-4-and-Intel-RealSense-D435）","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://thomaszb.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"GDB的使用","slug":"GDB的使用","date":"2021-02-10T06:19:54.000Z","updated":"2023-02-27T07:38:53.386Z","comments":true,"path":"2021/02/10/GDB的使用/","link":"","permalink":"https://thomaszb.cn/2021/02/10/GDB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"作为一个靠c语言吃饭程序猿，GDB调试程序是必须掌握的","text":"作为一个靠c语言吃饭程序猿，GDB调试程序是必须掌握的 GDB的简介 GDB用途 GDB是一款程序调试器，可以再程序运行时，一步一步的运行代码从而确定自己的错误发生在哪一行(GDB官网)。 GDB可以完成以下事情 启动程序，传入参数 打断点 分析程序停下来时发生了什么 在运行过程中改变事务 GDB适用语言 GDB支持哪些语言： Ada Assembly C C++ D Fortran Go Objective-C OpenCL Modula-2 Pascal Rust GDB的基本使用 GDB调试前的准备 在gdb使用前，需要先编写好程序，同时启动gdb还要按照如下顺序 查看是否安装好了gdb gdb --version 创建支持GDB调试的程序： gcc -g text.c 启动GDB调试 gdb a.out GDB的基本命令使用 当gdb开始运行后，进入调试界面，这时候通过输入各种命令就可以让程序实现不同的效果（相当于界面调试时点击的效果，如加断点，全速运行，单行运行）。具体命令如下所示： 命令/缩写 作用 run/r 让程序开始运行，或者重启该程序 quit 退出gdb模式 break/b+行/函数名 添加断点，可以添加都某个函数前，某行前 list 查看程序，每list以下程序就展示向下10行（断点前看行数） next/n 往下运行一行 info b 查看断点的情况 print/p 变量名 产看变量的信息（可以通过变量名=x的方式实现改变变量值） step 进入该行的函数 continue/c 让程序继续运行 GDB的高级功能 GDB除了支持上述调试命令外，还支持一些高级命令 运行shell的命令，在调试时可以执行shell命令查看外面的文件等 shell xxxx 日志功能 日志功能实现了对整个调试过程的记录，方便后续的分析 set logging on 观察点 通过设置观察点可以实现变量改变的监控，比如观察i变化，当程序运行时，监控的变量发生改变程序可以通知到控制台 watch *地址 // 监控某个地址的值 info watchpoints //查看观察点 GDB的进阶使用 GDB调试core文件 什么时core文件 当一个程序崩溃时，如果在打开core文件生成的情况下，会在指定目录下生成一个core文件，主要用于调试。 如果打开core文件的生成 core文件生成默认状况下是关闭的，所以要开启core文件的生成权限 查看当前shell的限制（ulimit介绍，ps:英语好可以直接看man手册） ulimit -a 解除对core文件生成的限制 ulimit -c unlimited 如何调试core文件（可以直接产看错误的行和原因） gdb xxx(运行的文件) core.xx(core文件) GDB调试正在运行的程序 当一个程序一直在运行时，可以通过gdb+进程号直接调试该程序 程序后台运行 ./a.out &amp; // 即在程序后面添加&amp; 查看程序进程号（ps命令介绍） ps -ef | grep xxx // 根据进程的名字xxx查找进程号 gdb调试正在运行的进程 gdb -p 进程号","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://thomaszb.cn/categories/C-C/"}],"tags":[]},{"title":"STM32 HAL学习记录","slug":"STM32-HAL学习记录","date":"2020-07-22T04:08:55.000Z","updated":"2023-07-13T16:03:20.849Z","comments":true,"path":"2020/07/22/STM32-HAL学习记录/","link":"","permalink":"https://thomaszb.cn/2020/07/22/STM32-HAL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"stm32系列从f7系列开始就已经不支持标准库了，为了更上时代的步伐，了解以下hal库的使用非常有必要。同时hal库开始，代码的移植将变得非常简单，stm32的各个系列开发使用的库函数基本都相同","text":"stm32系列从f7系列开始就已经不支持标准库了，为了更上时代的步伐，了解以下hal库的使用非常有必要。同时hal库开始，代码的移植将变得非常简单，stm32的各个系列开发使用的库函数基本都相同 SD卡使用过程 在32上使用HAL库配置SD卡很简单，唯一要注意的就是时钟问题，48Mhz的时钟一般没有什么问题 SD卡使用简介 SD卡的使用分为3个步骤 初始化 初始化时发送不同命令询问sd卡信息等，确认初始化sd卡可用（初始化一般要求时钟频率低） 写 读 所有步骤都是通过指令实现，SD卡的四线模式如下图所示，CMD引脚走的是命令，可以通过该引脚配置SD卡，具体命令可以网上查找 SD卡配置过程 使能SD卡传输 sd卡的使能很简单，如下配置就行 配置SD卡时钟 使能SD卡后可以看到有个SDMMC CLOCK（名字差不多就行），然后这里我将他的时钟配置为48Mhz（实测50M或者更高在我的这款SD卡上会出错）配置如下图所示 使用sd卡 sd卡的操作一般有读、写、擦除等，这些函数在HAL库都有提供，如下图所示 这里要注意擦除后最好延时一段时间再读，测试时直接读有出错。 FATFS的移植 FATFS简介 FATFS可以根据需求添加文件系统的构成，可以移植到ROM很小的单片机上（功能可能很少）。 FATFS文件系统就是提供了一套操作SD卡文件的API，可以直接调用提供的API对SD卡中的文件进行读写操作（而不是原始的对块进行操作）。将FATFS移植到单片机，所有文件操作的逻辑等都可以通过函数实现。 配置过程 配置过程说起来很复杂，需要将读写sd卡等常用的函数写道fatfs的driver里面，然后通过修改一些宏定义决定是否要启用某些功能。但使用cubemx只需要根据自己的需求使能或者关闭相关的功能即可，如下图 操作时遵循一下过程 挂载SD卡 判断挂载是否成功（不成功可能是没有格式化成FAT32格式）","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://thomaszb.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[]},{"title":"MSP430学习笔记","slug":"MSP430学习笔记","date":"2020-07-11T03:00:10.000Z","updated":"2023-07-13T16:01:49.689Z","comments":true,"path":"2020/07/11/MSP430学习笔记/","link":"","permalink":"https://thomaszb.cn/2020/07/11/MSP430%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"MSP430系列是TI的低功耗系列，是用于入门TI单片机的最好选择，相当于TI单片机中的51单片机，使用简单，外设不丰富（但基本该有的都有）","text":"MSP430系列是TI的低功耗系列，是用于入门TI单片机的最好选择，相当于TI单片机中的51单片机，使用简单，外设不丰富（但基本该有的都有） 1. MSP430简介 简介 MSP430是TI的超低功耗单片机，开发过程和51单片机差不多，但有比51单片机更多的资源以及更高的频率。 开发环境 MSP430使用TI的CCS作为开发环境，由于单片机的结构特殊，不能使用keil开发。ccs的开发环境比较好搭建，只需要注意全程英文环境就行。这里简单介绍一下获取例程的代码： 进入例程的网站 找到对应的例程下载 导入工程 2. io口控制 io控制寄存器 msp430的io控制寄存器特别多，不像51那样少，430的io控制寄存器在手册上有详细的说明，如下图所示： 有了详细的说明就可以对相应的寄存器进行控制了。 主要寄存器 PxIN为只读寄存器，在输入模式下可以读取按键上的电平。 PxOUT为输出控制寄存器，在输出模式下可以输出高电平或低电平。 PxDIR为输入输出选择寄存器，可以选择io口为输入或者输出（Bit=0为输入）。 PxREN上拉下拉是能寄存器，选择是否是能上下拉，是能条件下，PxOUT控制上下拉。 中断相关寄存器 PxIFG中断标志位，当某些事件发生时置1，开启中断的情况下进入中断，必须由软件清0。注意：当写入PxOUT和PxDIR时会对将相应的寄存器置0或1 PxIES确定什么边沿触发中断。0为上升沿，1为下降沿。 PxIE选择是否使能中断 PxSELx为功能选择寄存器，相当于复用。复用功能的选择在数据表（datasheet）中的Port Schematics中查看。 msp430作为输出配置步骤 配置PxDIR作为出 PxOUT为输出多少 msp430作为输入配置步骤 配置PxDIR为输入模式 配置PxREN使能上下拉（可以不使能这个，实际情况决定） 配置PxOUT确定是上拉还是下拉 读取PxIN获得输入的电平 3. 时钟控制 时钟系统简介 MSP430有很多系列，不同的款式有不同的时钟系统，这里从msp430g2553为例，对时钟配置过程做大概的记录。 MSP430g2553的时钟树如下图所示 一般时钟树的看法就是从左到由，左边是输入，右边是输出。可以大概看出来左边有3个部分，右边有3个输出。上面的黑色小方框是相应的控制寄存器。就可以大概得出MSP430g2553的时钟构成和相应的配置过程。 时钟树的详细配置 时钟配置的寄存器 DCOCTL 这是DCO时钟的控制寄存器，具体配置手册上有，用于确定DCO的频率和模式 BCSCTL1 BCSCTL2 BCSCTL3 IE1 IFG1 具体配置查看手册 时钟配置过程 MSP430的高速时钟只能从内部获取，但是内部的时钟并不是很精确，所以有很多校准值可以直接使用。所以实际配置过程中使用系统给的宏定义就行。 配置举例 MCLK 和 SMCLK 均为 1MHz， ACLK 设为 32.768kHz BCSCTL1 = CALBC1_1MHZ; // 要取得精确的1MHz，一定要调取校正参数 DCOCTL = CALDCO_1MHZ; // ACLK保持默认即可 MCLK 和 SMCLK 均为 16MHz， ACLK 设为 VLO BCSCTL1 = CALBC1_16MHZ; // 调取16MHz校正参数 DCOCTL = CALDCO_16MHZ; BCSCTL3 |= LFXT1S_2; // 设为VLO MCLK 为 4MHz， SMCLK 为 2MHz BCSCTL1 = CALBC1_8MHZ; // 先将DCO设为8MHz DCOCTL = CALDCO_8MHZ; BCSCTL2 |= DIVM_1 + DIVS_2; // 再对MCLK 2分频， SMCLK 4分频 MCLK 设为 32.768kHz 外部晶振 BCSCTL3 |= LFXT1S_0 + XCAP_3; // clock system setup while(IFG1 &amp; OFIFG) // wait for OSCFault to clear { IFG1 &amp;= ~OFIFG; _delay_cycles(100000); } _bis_SR_register(SCG1 + SCG0); // clock system setup BCSCTL2 |= SELM_3; 4. 中断控制 中断简介 中断就是系统的某个事件发生，若为该事件配置有中断，则系统会进入中断函数。所以要搞懂一块单片机的中断至少要懂得他的中断向量表，如下图。 有了这个表就知道有哪些中断，哪些中断时公用一个中断向量。 中断的使用 中断系统配置 msp430的中断系统比较简单，配置的话只需要对应好中断向量，以及打开某个标志位的中断，并在中断服务函数里面写上中断函数即可。 中断配置步骤 配置中断事件并打开中断（即配置中断向量） 是能中断 创建中断服务函数 按键举例 初始化按键、使能中断、清空中断标志位。 使用_BIS_SR(GIE)指令使能全局中断。 编写中断服务函数 中断服务函数写法： #pragma vector=PORT1_VECTOR // 编译指令，告诉编译器将函数与中断向量链接起来，vector后面是中断向量地址的宏定义。 __interrupt void Port_1(void)//__interrupt表示这是一个中断服务函数，后面的Port_1可以自己命名 { ...... } 5. 定时器 定时器简介 所有单片机中定时器都是非常重要的，定时器可以实现精准计时等操作。MSP430的定时器可以在手册上看到，由标题就可以轻易的知道，MSP430g2553的定时器分为TIM_A和TIM_B两个。定时器可以实现捕获、比较输出（PWM）等功能。 如何了解一个定时器 了解一个定时器，要从以下几个方面了解 计数器的位数（他的计数值保存在这里） 时钟来源 通道情况（可以作为比较、捕获等） 中断配置情况（如哪些状态位可以激活中断） 工作模式（连续、向上、向下等） 定时器的使用 定时器的不同工作模式 连续模式 连续模式下，定时器计数到溢出自动返回到0重新开始计数（有的单片机有自动重装载值，可能不一定返回到0）。 向上计数 向上跟连续模式不同的地方在于向上的溢出值可以自己设定，相当于可以自己设定多久过后溢出（这里其实是超过比较值、不应该叫做溢出。更方便）。 向上/向下 定时器达到设定的值后向下到0，这样才算一个周期，相当于周期乘以了2。 定时器中断 定时器的中断来源不同定时器不一样，msp430g2553的中断来源有CCR（捕获/比较）中断和TA0IFG（溢出）中断 CCR0中断 计数器的值达到CCR0时产生的中断 溢出中断 溢出中断一般是指TAR（计数器）为0相应的标记为置位，产生溢出中断。 定时器寄存器 这里的寄存器是以MSP430g2553的为例 TACTL 主要的控制寄存器，控制TIM_A的时钟来源、输入分频、模式、中断控制等等 TACCRX 比较值 TACCTLx 比较捕获配置 TAIV 存放了一些中断的标志位 配置举例 配置流程 选择时钟来源和分频值 确定定时器工作模式 跟据模式选择哪个中断 编写对应的中断服务函数 捕获 一般设置计数器为连续模式，定义全局变量count来确定是否捕获中途发生溢出（需开启中断）。 配置捕获模式，设置TACCTLx寄存器的CAP为1。 选择哪个引脚作为捕获输入口，配置CCRx模块的捕获源寄存器CCISx。 选择什么边沿捕获，设定CMx寄存器。 确定同步捕获还是异步捕获，SCS寄存器（一般为同步，更精准）。 CCR检测到带捕获功能IO口的电平边沿，瞬间读取TAR寄存器的值并写入TACCRx寄存器中等待读取。 比较 MSP430的PWM输出比较特殊。在该模式下，CCR0确定周期，CCRx确定占空比和输出引脚为TAx，步骤如下。 设定PWM的输出端口，跟据MSP430g2553的定义，.0端口不能用于输出。并设置IO口的功能为 TIMx_Ax ，如图所示。 设定 CCR0 和 CCRx 的值。 选择比较/捕获模块的输出模式(一般选用输出模式7来生成PWM波)。 选择定时器的时钟源和计数器源。 MSP430自动生成PWM波，CPU可进入低功耗模式。 低功耗模式进入方法：__BIS_SR(CPUOFF)，__BIS_SR直接控制系统状态寄存器。 串行通信 串行通信简介 常见的串行通信 串行通信常见的位IIC，SPI，UART等，MSP430在硬件上都支持，只需要配置寄存器就可以使用。 串行通信的介绍和相关信息 这个参考我的另一篇博客（各种通信协议笔记） MSP430串行通信的使用 寄存器 UCAxCTLx 配置寄存器 （一般选择默认的即可，即不用配置） UCAxRXIE 接收中断配置寄存器 UCAxTXIE 发送中断配置寄存器 TXBUF发送缓冲器 RXBUF接受缓冲器 UCAxBRx、UCAxMCTL 控制波特率的寄存器 配置流程 配置UCAxCTLx寄存器，一般不用配置，因为默认配置就是常用的8位，无奇偶校验等 时钟选择，USCI的时钟为BRCLK，它可以选择3个时钟来源。 波特率设置，通过配置配置UCAxBRx、UCAxMCTL寄存器达到配置的效果，得到固定波特率。下图附上16M主频下的常用波特率配置。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://thomaszb.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[]},{"title":"各种通信协议笔记","slug":"各种通信协议笔记","date":"2020-07-06T05:49:39.000Z","updated":"2023-07-13T15:56:37.389Z","comments":true,"path":"2020/07/06/各种通信协议笔记/","link":"","permalink":"https://thomaszb.cn/2020/07/06/%E5%90%84%E7%A7%8D%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/","excerpt":"单片机学习过程中协议是非常重要的，这里先记录几个协议，后面可能会继续添加","text":"单片机学习过程中协议是非常重要的，这里先记录几个协议，后面可能会继续添加 IIC协议 简介 一种半双工的通信方式，由数据线SDA和时钟线SCL构成。发送时高位在前低位在后，要确定IIC工作要确定下述条件（也就是通信过程中的步骤）： * 空闲状态 * 开始状态 * 停止信号 * 应答信号 * 数据的有效性 * 数据的传送 空闲状态 一般SDA和SCL都为高电平时为空闲状态，由上拉电阻拉高。 起始信号与停止信号 起始信号：SCL为高，SDA由高变低。 终止信号：SCL为高，SDA由低变高。 注：由上述可以看出，传输数据过程中，SCL为高电平时不要改变SDA状态。 应答信号 在传输完一个字节后，发送器释放数据总线（改变为上拉的接收模式）。判断接收器是否在下一个时钟发送一个低电平。 ACK：下一个时钟时为低电平 NACK：下一个时钟时为高电平（一般用Ā表示) 数据的有效性 有效的数据在高电平期间数据不会改变，如下图所示： 数据的传送 一个时钟周期传送1bit的数据 SPI协议 简介 SPI是一种全双工通信方式，由两根数据线MISO、MOSI，一根时钟线SCLK，一根片选线CS总共4跟线构成。相当于两个移位寄存器构成的循环移位寄存器，如下图所示： 一般使用SPI都为硬件实现，在SPI开始工作前我们要确定如下配置： 空闲状态 数据采集 数据格式 状态标志 主机或从机 速度 时钟空闲状态 确定时钟空闲时的状态，根据要驱动的外设确定。 数据采集 确定数据采集的时刻，为哪一个边沿时采集数据。根据哪个边沿和时钟空闲时状态就可以确定在哪一个时刻采集数据。 数据格式 确定数据帧的格式，确定MSB在前还是LSB在前，8位还是16位。 状态标志 在使用SPI时可能会出现的状态，一般有下面几种状态： 1. 发送缓冲器空闲 2. 接收缓冲器非空 3. 忙 状态和中断配合使用，可以确定什么时候进入中断执行相应的操作 特殊说明 NSS 是指CS位，可以选择是否使用硬件NSS Frame Format 帧格式有摩托罗拉和TI（TI的其实叫SSP而不是SPI） 串行UART通信 串行通信简介 UART 为串行异步全双工通信，串行通信由于时钟不同步，起始信号和终止信号之间传输的数据量一般不大（仅为1个字节左右）。它由两根线（一根TX，一根RX构成）下图为连接方式： 一般串行通信过程为：起始、数据、校验（可选）、结束（1-2位）如下图。 所以串行通信要配置的信号如下所示： 数据位数（九位模式下最后一位可以表示发送的信号为地址或数据） 是否启用奇偶校验（默认不启用） 停止位的个数（默认1位） 波特率（重要的选项，前面可以少配置） FSMC FSMC简介 FSMC也不算协议，是灵活的静态存储控制器，能够与同步或异步存储器和16位PC存储器卡连接。FSMC分为多个存储块，STM32F4的FSMC把1G的空间平均分为4块，每块有256M，然后每个块分为4个区，每个区大小64M，不同区之间的寻址通过区控制寄存器选择，其他则通过26位地址宽度寻址，实际上反应到外面的地址并不是28位的地址宽度，而是1个片选线加上25位的宽度（片选线有4根，相当于2位地址）。 stm32中使用fsmc后的sram等设备可以很方便的寻址，写入和擦除等，跟内部sram差别不大。 FSMC控制线 地址线（如A0-A25） 数据线（如D0-D15） 写信号（WE，即WR） 读信号（OE，即RD） 片选信号（CS） 字节控制（某些SRAM支持，即UB/LB） 注意事项 16位模式和8位模式对应的内部总线的最低为不同，16位时要左移1位，因为地址增加时2个字节的增加的。 FSMC有不同模式，不同模式对应不同的存储芯片，可以用芯片手册和FSMC对应（比如模式A可以独立设置读取和写入）。 突发（burst），与其说是突发，倒不如说时连续。突发访问感觉像是翻译上的失误，突发访问其实就是连续访问，写一个地址后连续读出接下来的一些数据（而不是一个地址一个数据）。 stm32中fsmc用 u32 test[100] __attribute__((at(0x680000))); 的方式进行地址的定义。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://thomaszb.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[]},{"title":"Conda创建虚拟环境","slug":"conda创建虚拟环境","date":"2020-06-03T01:52:27.000Z","updated":"2023-07-13T15:52:53.379Z","comments":true,"path":"2020/06/03/conda创建虚拟环境/","link":"","permalink":"https://thomaszb.cn/2020/06/03/conda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","excerpt":"使用python不能创建虚拟环境是非常痛苦的，作为库使用特别多的语言，版本一变，代码往往就跑不通了（做库的人不考虑低版本的兼容），所以通常要不同环境来存放不同版本的库","text":"使用python不能创建虚拟环境是非常痛苦的，作为库使用特别多的语言，版本一变，代码往往就跑不通了（做库的人不考虑低版本的兼容），所以通常要不同环境来存放不同版本的库 虚拟环境的作用 有时候要使用一个python库的不同版本，如tensorflow1和tensorflow2，这时候就需要创建两个虚拟环境，将不同的版本安装到不同的虚拟环境，然后根据需要，在不同的环境下进行工作。 更新conda conda update conda 创建一个虚拟环境 创建 使用该命令创建一个虚拟环境 conda create -n xxx python=3.x 查看虚拟环境 查看的时候使用前面带*号的为当前激活的环境 conda env list 激活虚拟环境 conda activate xxx （如果使用spyder使用 conda install spyder) 删除虚拟环境 conda remove -n xxx --all 删除虚拟环境某个包 conda remove --name env_name package_name 启用虚拟环境的jupyter 查看jupyter notebook kernel jupyter kernelspec list 删除jupyter notebook kernel jupyter kernelspec remove kernelname 在该环境下安装ipykernel conda install ipykernel 创建jupyter notebook kernel文件 conda install -n env_name ipykernel 激活conda环境 conda activate env_name 将环境写入notebook的kernel中 python -m ipykernel install --user --name env_name --display-name \"在jupyter中显示的环境名称\" 在改环境下启动jupyter notebook jupyter notebook","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://thomaszb.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"如何使用GIT","slug":"如何使用GIT","date":"2020-05-18T16:17:36.000Z","updated":"2023-07-13T15:43:46.149Z","comments":true,"path":"2020/05/19/如何使用GIT/","link":"","permalink":"https://thomaszb.cn/2020/05/19/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GIT/","excerpt":"程序猿必备技能","text":"程序猿必备技能 Github的介绍 github是一个代码托管平台，github可以实现对工程的托管，开源，版本备份，协同开发，比较著名的开源项目如Tensorflow等都在github上可以下载，对于版本控制来说非常重要。对于工科来讲特别重要。 Git和Github的关系 github是一个代码的托管平台，我们可以直接使用github网页端上传和备份自己的工程。但是对于程序员来说，如果更新一次版本都需要跑到网页端，然后自己根据修改了哪些文件选择文件上传，这是非常麻烦的。所以就可以使用Git这个管理工具，通过几行命令，就可对比该仓库目前哪些变化了，然后添加到仓库，再选择一个远程仓库提交，方便了工程的管理。 Git基本使用 Git配置命令 首先就是github的配置，一般配置命令前面都有一个config，git的系统配置保存在 Git/etc/gitconfig ，git的全局配置保存在 C:用户/xxx(用户名)/.gitconfig 配置项 命令 查看所有配置（l表示list） git config -l 查看系统配置 git config --system --list 查看全局配置 git config --global --list 编辑全局用户名 git config --global user.name \"xxxx\" 编辑全局邮箱 git config --global user.email \"xxx\" 设置当前git代理 git config http.proxy http://127.0.0.1:10809 设置全局git代理 git config --global http.proxy http://127.0.0.1:10809 取消当前代理 git config --unset http.proxy 取消全局代理 git config --global --unset http.proxy git的基本配置很简单，只需配置好全局邮箱和全局用户名就行，具体命令如上所述。至于其他的根据需要进行配置，我这里还介绍了常用的代理配置方法。 Git基本使用命令 Git在平时的使用中，分为4个（层）目录，通过命令使自己的文件在不同地方保存。 Workspace：工作目录，平时自己使用的文件夹 index/Stage：暂存区，在这个阶段，可以反悔（不提交） Repository：资源仓库，资源目录，分布式版本控制中本地的仓库，其中HEAD（.git隐藏文件夹里面）指向最新放入仓库的版本 Remote：远程的Github服务器或Gitee的服务器（看自己爱好） git操作一般流程 正向（也就是修改东西后上传）： 查看当前文件的状态：git status 将xxx添加到暂存区（.代表所有文件）：git add xxx 将暂存区文件提交到本地资源仓库，xxx代表当前版本的说明（提交的信息）：git commit -m \"xxx\" 将本地资源仓库的文件提交到远程服务器：git push 反向（也就是回退版本之类的）： 将暂存区里面的东西取消暂存 ：git checkout 将本地仓库里面某一个历史版本回滚：git reset xxx（这里的xxx为版本的hash值，可以在仓库中看） 从远程仓库下载 ：git pull Git的忽略 有时候我们在提交时，不想所有文件都提交到git仓库里面（比如训练集），就必须要忽略这些文件。忽略文件步骤如下 在主目录下建立.gitignore文件 添加忽略规则： 注释：”#“ 通配符：\"*\" 例外规则，将不被忽略：”!” 某个路径：”/“ Git远程仓库 自己的项目除了在本地保存外，还可以提交到远程服务器。远程服务器可以根据自己需要选择，如：Github、Gitee、自己搭建Gitlab。这里我主要使用Github。 免密码登录（使用ssh） 所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个。 去本地查看ssh的目录下有无key，即查看是否已经存在id_rsa.pub或id_dsa.pub 12cd ~./sshls 如果没有，则创建一个ssh key 1ssh-keyge 拷贝id_rsa.pub文件里面的公钥放到git的sshkey下面 到这一步显然已经完了，但是如果仓库已经使用过https上传，有时需要手动修改一下（建议重新下载仓库） 查看当前地址：注意看连接，如果时https开头说明之前是用https进行连接的，需要更换为ssh模式 1git remote -v 移除https方式 1git remote rm origin 添加新的方式 1git remote add origin xxx 地址为下图所示地址: 如何新建仓库 在Github上先建一个仓库：直接在首页的左边有一个New，可以选择新建仓库 将创建的仓库克隆到本地，然后开始自己的工程（不然的话容易出现版本冲突）。 克隆下来后可以直接将自己的工程文件复制到该目录下继续工作。（或则将克隆下来的全部文件复制到工程目录下） GIT分支 分支的作用 分支常用来合作、以及发行不同版本（如开发板、稳定版）等。可以保证代码不冲突，共存多个版本。 使用分支的常用命令 功能 命令 查看当前的分支 git branch 查看远程仓库上的分支 git branch -r 新建一个名为xxx的分支 git branch xxx 切换到xxx分支 git checkout xxx 新建一个xxx分支，并切换到该分支 git checkout -b xxx 删除xxx分支 git branch -d xxx 删除远程仓库中的xxx分支 git push origin --delet xxx 将远程的yyy分支关联到本地的xxx分支 git checkout -b xxx origin/yyy 提交当前代码到xxx分支（默认是主分支） git push origin xxx 提交当前分支到远程的xxx分支，-u后以后该分支就默认连接到远程的xxx分支 git push -u origin xxx 分支的合并 通常不同项目组开发一个项目时，有些项目组要调用另一个项目组的代码，所以就需要合并，合并后修改代码后提交可能会冲突，选择保留哪一个即可。 git merge xxx合并指定分支到当前分支（合并时有可能会遇到冲突，选择要保留的既可）","categories":[{"name":"程序猿基础技能","slug":"程序猿基础技能","permalink":"https://thomaszb.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"如何使用v2ray搭建自己的梯子","slug":"如何使用v2ray搭建自己的梯子","date":"2020-05-18T01:47:28.000Z","updated":"2023-07-13T15:47:07.029Z","comments":true,"path":"2020/05/18/如何使用v2ray搭建自己的梯子/","link":"","permalink":"https://thomaszb.cn/2020/05/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A2%AF%E5%AD%90/","excerpt":"作为一个好公民，这个只是用来学习的","text":"作为一个好公民，这个只是用来学习的 购买一台外网服务器 想要访问被墙掉的网页，就要有可以访问的外网服务器帮自己转发，所以需要买一台外网的服务器，外网的服务器有很多种选择，服务器选择点这里查看。 服务器端操作 安装v2ray 使用bash &lt;(curl -L -s https://install.direct/go.sh)命令安装，bash命令会自动下载，安装。昨天试的时候安装不了甚至还自动给我下载了unzip，特别方便。当然也可以使用其他命令安装，这里不做介绍。 设置开机自启 这一步其实不太需要，因为服务器一般一直都是开机状态不会关机。不过想要设置的话可以使用以下两个命令设置。 1. systemctl start v2ray 2. systemctl enable v2ray 第一个命令为启动一个服务，第二个命令为开机自动启动一个服务，这一步结束了就相当于已经启动v2ray服务器端进程了（systemctl命令介绍）。 启动v2ray 除了上一步介绍的启动方法之外，还可以使用service v2ray start/stop/status来启动、关闭或者查看状态。一般启动后都要用service v2ray status查看是否启动成功。 查看v2ray信息 通过cat /etc/v2ray/config.json查看配置信息，配置信息里面信息也可以自己更改，默认的模式是vmess模式，可以根据需求自己再更改（vmess模式目前不是最安全的，会被识别，可以用websocket+tls伪装更安全）。这里的配置信息需要记住\"inbounds\"里面的信息，包括port，id，alterID三个信息，待会儿客户端连接时需要用到。 客户端操作(主要时windows) 安装v2ray 安装v2ray有很多种方法，我只介绍一种，点击这里下载客户端。选择v2rayN-Core.zip，这个安装包包含了v2rayN和v2ray-core，下载后可以直接使用。 下载后选择一个目录解压，解压后得到一堆文件，运行以下文件 配置客户端 打开客户端，选择下面配置，当然如果配置时不是用的vmess就选其它的 然后把服务器看到的信息按下面顺序填入客户端 启动客户端 配置完后启动开始上网吧","categories":[{"name":"程序猿基础技能","slug":"程序猿基础技能","permalink":"https://thomaszb.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"如何使用hexo搭建个人博客","slug":"如何使用hexo搭建个人博客","date":"2020-05-15T12:06:42.000Z","updated":"2023-07-13T15:48:34.789Z","comments":true,"path":"2020/05/15/如何使用hexo搭建个人博客/","link":"","permalink":"https://thomaszb.cn/2020/05/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"这就是这个博客的来源","text":"这就是这个博客的来源 准备工作 我这里使用github+hexo的组合搭建，所以要安装git和hexo，git安装我后面再建个博客写，这里我先介绍hexo的安装 官方教程：文档 | Hexo 下载nodejs 一般选择LTS（长期支持版）。安装完后有两个组件，一个是nodejs组件（hexo需要nodejs支持），一个是npm软件管理包。下载下来安装一直点next差不多就可以了。 下载完后用node -v和npm -v查看是否安装成功。 安装cnpm（换成淘宝源） 由于npm服务器在国外，下载速度慢，所以换成cnpm。使用命令npm install -g cnpm --registry=https://registry.npm.taobao.org安装。 利用cnpm安装hexo博客 命令cnpm install -g hexo-cli，-g的意思是全局安装，就可以在命令行使用这个命令（相当于添加环境变量）。安装后使用hexo -v查看是否安装成功。 正式搭建hexo博客 创建博客的空间 创建一个存放博客文件的空间，以后博客的管理等等都在该空间 hexo博客常用命令 初始化一个博客：hexo init 创建一篇博客：hexo n \"xxx\"，创建的博客默认保存在source/_posts/ 清理：hexo clean 生成：hexo g 启动：hexo s 删除博客：删除博客，然后清理、生成、启动 将hexo博客同步到github云端 在github上创建博客的仓库，名称为username.github.io 安装git部署插件：cnpm install --save hexo-deployer-git 配置_config.yml文件，在最后的Deployment配置如下 这里要注意，如如果使用ssh方式提交（不想输入密码）需要修改git仓库的地址为ssh方式 部署到云端，现在默认下会使用https上传，输入github账户和密码就行了：hexo d 主题配置 基础主题使用 hexo的主题配置分三步走 选择主题并下载 在_config.yml文件中更换主题 在主题的config文件中修改个人信息 选择主题 方法：在github上面搜索hexo-thmes 修改_config.yml文件 配置该主题 修改主题文件下的_config.yml文件 进阶主题配置 进阶的主题配置参考了这篇文章 点击效果 ​ 1. 在主题的_config.yml下添加动态配置 123cursor_effect: enabled: true type: love # fireworks：礼花 | explosion：爆炸 | love：浮出爱心 | text：浮出文字 在\\themes\\next\\layout\\_layout.swig末尾添加，用于动态配置点击效果 12345678910111213&#123;% if theme.cursor_effect %&#125; &#123;% if theme.cursor_effect.type == &quot;fireworks&quot; %&#125; &lt;script src=&quot;/js/cursor/fireworks.js&quot;&gt;&lt;/script&gt; &#123;% elseif theme.cursor_effect.type == &quot;explosion&quot; %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/cursor/explosion.min.js&quot;&gt;&lt;/script&gt; &#123;% elseif theme.cursor_effect.type == &quot;love&quot; %&#125; &lt;script src=&quot;/js/cursor/love.min.js&quot;&gt;&lt;/script&gt; &#123;% elseif theme.cursor_effect.type == &quot;text&quot; %&#125; &lt;script src=&quot;/js/cursor/text.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 创建以下4个文件，并复制到\\themes\\next\\source\\js\\coursor下 fireworks.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154class Circle &#123; constructor(&#123; origin, speed, color, angle, context &#125;) &#123; this.origin = origin this.position = &#123; ...this.origin &#125; this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 &#125; draw() &#123; this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() &#125; move() &#123; this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ &#125;&#125;class Boom &#123; constructor (&#123; origin, context, circleCount = 16, area &#125;) &#123; this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] &#125; randomArray(range) &#123; const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] &#125; randomColor() &#123; const range = [&#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;] return &#x27;#&#x27; + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) &#125; randomRange(start, end) &#123; return (end - start) * Math.random() + start &#125; init() &#123; for(let i = 0; i &lt; this.circleCount; i++) &#123; const circle = new Circle(&#123; context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) &#125;) this.circles.push(circle) &#125; &#125; move() &#123; this.circles.forEach((circle, index) =&gt; &#123; if (circle.position.x &gt; this.area.width || circle.position.y &gt; this.area.height) &#123; return this.circles.splice(index, 1) &#125; circle.move() &#125;) if (this.circles.length == 0) &#123; this.stop = true &#125; &#125; draw() &#123; this.circles.forEach(circle =&gt; circle.draw()) &#125;&#125;class CursorSpecialEffects &#123; constructor() &#123; this.computerCanvas = document.createElement(&#x27;canvas&#x27;) this.renderCanvas = document.createElement(&#x27;canvas&#x27;) this.computerContext = this.computerCanvas.getContext(&#x27;2d&#x27;) this.renderContext = this.renderCanvas.getContext(&#x27;2d&#x27;) this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false &#125; handleMouseDown(e) &#123; const boom = new Boom(&#123; origin: &#123; x: e.clientX, y: e.clientY &#125;, context: this.computerContext, area: &#123; width: this.globalWidth, height: this.globalHeight &#125; &#125;) boom.init() this.booms.push(boom) this.running || this.run() &#125; handlePageHide() &#123; this.booms = [] this.running = false &#125; init() &#123; const style = this.renderCanvas.style style.position = &#x27;fixed&#x27; style.top = style.left = 0 style.zIndex = &#x27;999999999999999999999999999999999999999999&#x27; style.pointerEvents = &#x27;none&#x27; style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener(&#x27;mousedown&#x27;, this.handleMouseDown.bind(this)) window.addEventListener(&#x27;pagehide&#x27;, this.handlePageHide.bind(this)) &#125; run() &#123; this.running = true if (this.booms.length == 0) &#123; return this.running = false &#125; requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) =&gt; &#123; if (boom.stop) &#123; return this.booms.splice(index, 1) &#125; boom.move() boom.draw() &#125;) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) &#125;&#125;const cursorSpecialEffects = new CursorSpecialEffects()cursorSpecialEffects.init() explosion.min.js 1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; love.min.js 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.οnclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); text.js 123456789101112131415161718192021222324var a_idx = 0;jQuery(document).ready(function($) &#123; $(&quot;body&quot;).click(function(e) &#123; var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot; ,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;); var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); var x = e.pageX, y = e.pageY; $i.css(&#123; &quot;z-index&quot;: 99999, &quot;top&quot;: y - 28, &quot;left&quot;: x - a[a_idx].length * 8, &quot;position&quot;: &quot;absolute&quot;, &quot;color&quot;: &quot;#ff7a45&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 &#125;, 1500, function() &#123; $i.remove(); &#125;); a_idx = (a_idx + 1) % a.length; &#125;);&#125;); 新建页面 添加自己的分类页面hexo new page categories 修改categories里面的index.md文档，改成如下 12345---title: 分类date: 2021-03-03 22:39:24type: categories--- 给自己的文章添加categories属性，并且clean后重新生成 动态背景 添加宠物 安装插件 npm install -save hexo-helper-live2d 选择一个宠物 宠物查看网址（https://huaji8.top/post/live2d-plugin-2.0/） 下载相应的插件 npm install live2d-widget-model-xxxx // xxx代表宠物的名称 站点配置文件下加入 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false model: use: live2d-widget-model-wanko #选择哪种模型 display: #放置位置和大小 position: right width: 150 # 大小 height: 300 # 离地面的高度 mobile: show: false #是否在手机端显示 遇到的问题 公式：不同的主题参考不同的改法，不过一般都需要更换一些更好的渲染器：Hexo中的数学公式 - 简书 (jianshu.com) 多设备博客同步问题 之前一直有两个设备，使用时问题好像不大，不过现在我只有一个设备，而且工作经常在ubuntu下，有时想要记录个东西就比较麻烦。目前我的解决方案是： 将source文件夹中的博客同步到github 在不同的环境下各自生成一个博客的空间 这里记录一下博客的初始化 正常安装node，按照主题volants的需求（node和npm的版本一定要满足）： 1234Hexo: 5.4 ~ 6.xhexo-cli: 4.3 ~ latestnode.js: 16.x LTS ~ latest LTSnpm: 8.x ~ latest LTS 使用hexo init初始化博客空间，后面的命令都在该空间执行 检查空间下的插件和版本hexo -v，如果hexo版本不满足要求则需要升级 123456789# 更新 package.json 中的 hexo 及个插件版本npm install -g npm-check # 检查之前安装的插件，都有哪些是可以升级的 npm install -g npm-upgrade # 升级系统中的插件npm-checknpm-upgrade# 更新 hexo 及所有插件cnpm update# 确认 hexo 已经更新hexo -v 由于使用到公式，需要换一下更好用的渲染器 12npm un hexo-renderer-markednpm i hexo-renderer-pandoc 这里由于pandoc的兼容性不好，ubuntu下主要通过github安装2.2.3.2版本：https://github.com/jgm/pandoc/releases?page=6 pandoc需要自己安装软件，上面的命令只是下载一个调用pandoc的脚本。 除此之外，还需要安装一些其他插件： 123npm i hexo-theme-volantis # 主题npm i -S hexo-generator-json-content # 评论系统npm install --save hexo-deployer-git # 用于deploy到github 将_config.yml覆盖，博客复制到source目录下 修改配置文件：node_modules/HEXO-THEME-VOLANTIS/source/css/_first/base_first.style ​ 修改自己喜欢的透明度 123.translucent @supports (backdrop-filter: blur(20px)) background: alpha($color-card, .6) !important hexo g生成hexo s查看是否成功","categories":[{"name":"程序猿基础技能","slug":"程序猿基础技能","permalink":"https://thomaszb.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"如何写markdown","slug":"如何写markdown","date":"2020-05-14T02:55:53.000Z","updated":"2023-02-27T07:38:53.401Z","comments":true,"path":"2020/05/14/如何写markdown/","link":"","permalink":"https://thomaszb.cn/2020/05/14/%E5%A6%82%E4%BD%95%E5%86%99markdown/","excerpt":"用于写博客","text":"用于写博客 工具 使用vscode vscode默认集成了markdown文档编辑插件，使用vscode打开.md文件后使用ctrl+shift+p调出主命令框，输入markdown，选择打开侧边预览 ，这样就可以一边编辑文档一边看效果： 使用typora typora相比vscode界面就要优雅多了。typora可以直接百度搜索然后官网下载，下载后有15天免费试用，之后需要89元购买。 小技巧 查看源代码： ctrl+/ 插入图片： 插入图片现在通常先把图片放在图床里面，再通过图床放入到博客里面。我一般使用Picgo作为图床的工具，使用腾讯云cos存储作为图床，配置方法可以看官网教程。 使用typora可以将图片直接粘贴到markdown文档中，typora自动上传并将图片替换为图片链接。将插入图片时改为上传图片，上传服务选择PicGo，选择PicGo安装路径就可以了。 语法 基本语法 标题 #号后面加空格可以生成标题，根据#号的多少确定是几级标题 字体 12345678加粗： 用**号包裹要加粗的字，比如**hello**斜体： 用*号包裹要加斜体的字，比如*hello*斜体加粗： 用***号包裹要加斜体加粗的字，比如***hello***删除线： 用~~号包裹要加删除线的字，比如~~hello~~ 引用 在要引用的文字前面加&gt;即可，可以加多个嵌套 分割线 三个以上的-或则*，比如：--- 图片 一般先将图片转化为链接，再用链接插入，插入方式：![图片名](图片链接) 超链接 用法：[链接名称](地址) 列表 123456无序列表 用-+*中任何一个都可以，符号后面需要加上空格，如：* 无序列表有序列表 数字加点，点后面加空格，如： 7. 列表列表嵌套 回车后按tap，自动按照之前规则嵌套，如果需要换成有/无序列表，则删除前面的序号，换成无序列表或则有序列表 表格 123456789101112表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 第二行分割表头和内容，一二两行是必要的，在typora中，写号一二两行后，就可以通过左上角快速调整表格大小。&#x27;-&#x27;有一个就行，为了对齐，多加了几个文字默认居左&#x27;-&#x27;的两边加：表示文字居中&#x27;-&#x27;的右边加：表示文字居右要输入|时，使用&amp;#124;替换注：原生的语法两边都要用 | 包起来。此处省略 代码 单行： 反引号包起来（键盘左上角1前面那个符号）：`hello world` hello world 代码块： ```c（即三个点加所需要的语言） 1234567#include &quot;stdio.h&quot;int main()&#123; printf(&quot;hello world\\r\\n&quot;); return 0;&#125; 公式 在typora中使用$$来写公式 其他 特殊符号防转义 在符号前加入\\转义字符如\\# \\&gt; 插入图片时的更多选项 markdown支持html语法，想要对图片插入调整则需要用到html语法：&lt;img&gt;，其属性有： src：设置图片的位置 width/height：设置图片的大小 alt：设置图片的备用内容（找不到图片时显示的内容） 设置超链接：&lt;a&gt; &lt;img&gt; &lt;/a&gt;（使用a标签） align：对齐 1&lt;img src=&quot;xxx&quot;align=&quot;center&quot; &gt; 文章简介 没点进去文章就能看到的部分，用&lt;!--more--&gt;分割 文字居中 用html的标签语法，可以设置属性居中：&lt;p&gt; &lt;\\p&gt; align：对齐 参考文章 Hexo中的数学公式 - 简书 (jianshu.com)","categories":[{"name":"程序猿基础技能","slug":"程序猿基础技能","permalink":"https://thomaszb.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"}],"tags":[]}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"https://thomaszb.cn/categories/C-C/"},{"name":"机器人基础","slug":"机器人基础","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9F%BA%E7%A1%80/"},{"name":"机器人","slug":"机器人","permalink":"https://thomaszb.cn/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://thomaszb.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"程序猿基础技能","slug":"程序猿基础技能","permalink":"https://thomaszb.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"},{"name":"专利","slug":"专利","permalink":"https://thomaszb.cn/categories/%E4%B8%93%E5%88%A9/"},{"name":"深度学习","slug":"深度学习","permalink":"https://thomaszb.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]}