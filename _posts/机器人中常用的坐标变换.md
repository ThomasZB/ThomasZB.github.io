---
title: 机器人中常用的坐标变换
date: 2022-09-21 14:25:17
tags:
categories: 机器人
plugins:
  - mathjax
---

<p align="center">
    简单的记录一下
</p>

<!--more-->

## 位姿的表示

描述空间中一个物体需要知道物体的位置，比如二维下物体的位置为$(x,y)$，同时还需要知道物体的姿态（也可以说是朝向），二维下可以用物体朝向与x轴的夹角$\theta$表示。则该物体可以使用位姿来描述$(x,y,\theta)$

上述方法描述虽然方便直观，但在数学运算上却不方便，为了方便计算两坐标系间距离，坐标变换等通常用矩阵的形式表示坐标

1. 二维情况下角度的矩阵表达-旋转矩阵（可以表示将物体旋转$\theta$）
   $$
   R=
   \begin{aligned}
       \begin{bmatrix}
           cos\theta & -sin\theta \\
           sin\theta & cos\theta
       \end{bmatrix}
   \end{aligned}
   $$

2. 齐次变换矩阵（可以表示将物体平移和旋转）
   $$
   T=
   \begin{aligned}
       \begin{bmatrix}
           R & p \\
           0 & 1
       \end{bmatrix}
   \end{aligned}
   =
   \begin{aligned}
       \begin{bmatrix}
           cos\theta & -sin\theta & x \\
           sin\theta & cos\theta & y \\
           0 & 0 & 1
       \end{bmatrix}
   \end{aligned}
   $$

## 常用的变换结论

以world坐标系为参考，A的位姿为$(x_1,y_1,\theta_1)$，B的位姿为$(x_2,y_2,\theta_2)$，在这样的条件下有以下几种坐标变换（括号里给出实际用途），首先，A和B的齐次变换矩阵如下（A和B即可以是物体位姿，也可以是坐标系位姿）：

$$
A=
\begin{aligned}
    \begin{bmatrix}
        cos\theta_1 & -sin\theta_1 & x_1 \\
        sin\theta_1 & cos\theta_1 & y_1 \\
        0 & 0 & 1
    \end{bmatrix}
\end{aligned}
$$

$$
B=
\begin{aligned}
    \begin{bmatrix}
        cos\theta_2 & -sin\theta_2 & x_2 \\
        sin\theta_2 & cos\theta_2 & y_2 \\
        0 & 0 & 1
    \end{bmatrix}
\end{aligned}
$$

1. B坐标系到A坐标系的坐标变换（将小车从B坐标系转换到A坐标系的坐标变换）
   $$
   T=A^{-1}B
   $$

2. A坐标系和B坐标系的相对位姿，也可以是B到A的相对位姿（计算两小车之间的距离）
   $$
   \Delta=A^{-1}B
   $$

   * 相对位姿的几何计算也经常使用

     ![image-20220922111304732](https://pic-1302177449.cos.ap-chongqing.myqcloud.com/blog_pic/%20image-20220922111304732.png)

     * 计算在world坐标系下的差（蓝线）

     $$
     \Delta x=x_2-x_1
     $$

     $$
     \Delta y = y_2-y_1
     $$

     * 计算B在A的坐标

     $$
     x_3=\Delta x\cdot cos\theta_1+\Delta y\cdot sin\theta_1
     $$

     $$
     y_3=-\Delta x\cdot sin\theta_1+\Delta y\cdot cos\theta_1
     $$

     $$
     \theta_3=\theta_2-\theta_1
     $$

3. B在A坐标系下的位姿（将小车从World坐标系转换到A坐标系）
   $$
   P=A^{-1}B
   $$

4. A的位姿是相对World，B的位姿是相对于A，则B在World中的位姿（将小车从A坐标系转换到World坐标系）
   $$
   P=AB
   $$

## 绕固定轴旋转

下面的表达式中使用简写$crx$代表$cos(rotation_x)$，也就是x轴方向旋转的cos值，srx同理。

绕x轴旋转得到的旋转矩阵：
$$
R_{rx}=
\begin{aligned}
    \begin{bmatrix}
        1&0&0\\0&crx&-srx\\0&srx&crx
    \end{bmatrix}
\end{aligned}
$$
绕y轴旋转得到的旋转矩阵：
$$
R_{ry}=\begin{aligned}\begin{bmatrix}cry&0&sry\\0&1&0\\-sry&0&cry\end{bmatrix}\end{aligned}
$$
绕z轴旋转得到的旋转矩阵：
$$
R_{rz}=\begin{aligned}\begin{bmatrix}crz&-srz&0\\srz&crz&0\\0&0&1\end{bmatrix}\end{aligned}
$$

## 欧拉角

欧拉角的思想很简单，将空间中任意一个姿态分解成3个顺序旋转（也就是说按照规则转3次后得到姿态）。这样就可以用3个变量表示空间中任意姿态了。根据旋转的规则不同，欧拉角的值也有所不同。由于欧拉角按顺序旋转，旋转的方式有很多种，可以按下分类：

> 绕固定轴旋转：X-Y-Z，Z-X-Y...
>
> 绕旋转后的轴旋转：X-Y-Z，Z-X-Y...

对于不同的旋转方式，所对应的运算也不相同。为了便于讨论，在机器人领域中，我们常用`rpy`角，rpy角是一种欧拉角，其规则为：**旋转顺序：Z-Y-X（不一定？跟坐标系定义有关），绕旋转后的轴旋转**。

rpy角和欧拉角的转换方式如下（我这里的zyx是对应于lidar的，相当于z在上的右手坐标系，对于不同的坐标系得到的结果也不同）
$$
R=R_{yaw}\times R_{pitch}\times R_{roll}=R_{rz}\times R_{ry}\times R_{rx}
$$

>对于不同坐标系，比如相机坐标系（z朝前的右手坐标系），yaw角对应的就是$R_{ry}$。总之公式前半部分一定是对的，后半部分根据坐标系不同需要注意一下。

# 工具

##  ros中的tf::transform

## 相关头文件

1. 各种类型

```cpp
#include <tf/transform_datatypes.h>
```



### 构造

1. 已知$(x,y,\theta)$

   ```cpp
   tf::Transform tf1;
   tf1.setOrigin(tf::Vector3(0, 0, 0));
   tf::Quaternion q;
   q.setRPY(0, 0, 0);
   tf1.setRotation(q);
   ```

2. 已知四元数，转化为`tf::Quaternion`再设置tf的四元数

   ```cpp
   tf::Quaternion q(x,y,z,w);
   tf1.setRotation(q);
   ```

3. 将里程计的数据，即`todo`格式的四元数转化为`tf::Quaternion`

   ```cpp
   tf::Quaternion q;
   tf::quaternionMsgToTF(msg->pose.pose.orientation, q);
   tf1.setRotation(q);
   ```

4. 得到的tf，即`geometry_msgs::TransformStamped`转`tf::transform`

   ```cpp
   geometry_msgs::TransformStamped tfGeom;
   tf::Transform tf1;
   tf1.setOrigin(tf::Vector3(tfGeom.transform.translation.x, tfGeom.transform.translation.y, tfGeom.transform.translation.z));
   tf::Quaternion q(tfGeom.transform.rotation.x, tfGeom.transform.rotation.y,
                  tfGeom.transform.rotation.z,
                  tfGeom.transform.rotation.w);
   tf1.setRotation(q);
   ```

   

### 转化

1. 还原回$x,y,\theta$

   ```cpp
   tf::Transform t;
   // 得到变换的平移部分
   tf::Vector3 origin = t.getOrigin();
   double x = origin.x();
   double y = origin.y();
   double z = origin.z();
   // 得到变换的旋转部分
   tf::Quaternion rotation = t.getRotation();
   double yaw = tf::getYaw(rotation);
   ```
   
   

### 使用

